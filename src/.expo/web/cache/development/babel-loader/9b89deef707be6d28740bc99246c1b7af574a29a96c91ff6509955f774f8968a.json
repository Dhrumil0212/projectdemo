{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\Dhrumil\\\\VS Code\\\\projectdemo\\\\src\\\\node_modules\\\\@react-native\\\\virtualized-lists\\\\Lists\\\\VirtualizedList.js\";\nimport Platform from \"react-native-web/dist/exports/Platform\";\nimport RefreshControl from \"react-native-web/dist/exports/RefreshControl\";\nimport ScrollView from \"react-native-web/dist/exports/ScrollView\";\nimport View from \"react-native-web/dist/exports/View\";\nimport StyleSheet from \"react-native-web/dist/exports/StyleSheet\";\nimport findNodeHandle from \"react-native-web/dist/exports/findNodeHandle\";\nimport Batchinator from '../Interaction/Batchinator';\nimport clamp from '../Utilities/clamp';\nimport infoLog from '../Utilities/infoLog';\nimport { CellRenderMask } from './CellRenderMask';\nimport ChildListCollection from './ChildListCollection';\nimport FillRateHelper from './FillRateHelper';\nimport StateSafePureComponent from './StateSafePureComponent';\nimport ViewabilityHelper from './ViewabilityHelper';\nimport CellRenderer from './VirtualizedListCellRenderer';\nimport { VirtualizedListCellContextProvider, VirtualizedListContext, VirtualizedListContextProvider } from './VirtualizedListContext.js';\nimport { computeWindowedRenderLimits, keyExtractor as defaultKeyExtractor } from './VirtualizeUtils';\nimport invariant from 'invariant';\nimport nullthrows from 'nullthrows';\nimport * as React from 'react';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst ON_EDGE_REACHED_EPSILON = 0.001;\nlet _usedIndexForKey = false;\nlet _keylessItemComponentName = '';\nfunction horizontalOrDefault(horizontal) {\n  return horizontal ?? false;\n}\nfunction initialNumToRenderOrDefault(initialNumToRender) {\n  return initialNumToRender ?? 10;\n}\nfunction maxToRenderPerBatchOrDefault(maxToRenderPerBatch) {\n  return maxToRenderPerBatch ?? 10;\n}\nfunction onStartReachedThresholdOrDefault(onStartReachedThreshold) {\n  return onStartReachedThreshold ?? 2;\n}\nfunction onEndReachedThresholdOrDefault(onEndReachedThreshold) {\n  return onEndReachedThreshold ?? 2;\n}\nfunction getScrollingThreshold(threshold, visibleLength) {\n  return threshold * visibleLength / 2;\n}\nfunction scrollEventThrottleOrDefault(scrollEventThrottle) {\n  return scrollEventThrottle ?? 50;\n}\nfunction windowSizeOrDefault(windowSize) {\n  return windowSize ?? 21;\n}\nfunction findLastWhere(arr, predicate) {\n  for (let i = arr.length - 1; i >= 0; i--) {\n    if (predicate(arr[i])) {\n      return arr[i];\n    }\n  }\n  return null;\n}\nclass VirtualizedList extends StateSafePureComponent {\n  static contextType = VirtualizedListContext;\n  scrollToEnd(params) {\n    const animated = params ? params.animated : true;\n    const veryLast = this.props.getItemCount(this.props.data) - 1;\n    if (veryLast < 0) {\n      return;\n    }\n    const frame = this.__getFrameMetricsApprox(veryLast, this.props);\n    const offset = Math.max(0, frame.offset + frame.length + this._footerLength - this._scrollMetrics.visibleLength);\n    if (this._scrollRef == null) {\n      return;\n    }\n    if (this._scrollRef.scrollTo == null) {\n      console.warn('No scrollTo method provided. This may be because you have two nested ' + 'VirtualizedLists with the same orientation, or because you are ' + 'using a custom component that does not implement scrollTo.');\n      return;\n    }\n    this._scrollRef.scrollTo(horizontalOrDefault(this.props.horizontal) ? {\n      x: offset,\n      animated\n    } : {\n      y: offset,\n      animated\n    });\n  }\n  scrollToIndex(params) {\n    const {\n      data,\n      horizontal,\n      getItemCount,\n      getItemLayout,\n      onScrollToIndexFailed\n    } = this.props;\n    const {\n      animated,\n      index,\n      viewOffset,\n      viewPosition\n    } = params;\n    invariant(index >= 0, `scrollToIndex out of range: requested index ${index} but minimum is 0`);\n    invariant(getItemCount(data) >= 1, `scrollToIndex out of range: item length ${getItemCount(data)} but minimum is 1`);\n    invariant(index < getItemCount(data), `scrollToIndex out of range: requested index ${index} is out of 0 to ${getItemCount(data) - 1}`);\n    if (!getItemLayout && index > this._highestMeasuredFrameIndex) {\n      invariant(!!onScrollToIndexFailed, 'scrollToIndex should be used in conjunction with getItemLayout or onScrollToIndexFailed, ' + 'otherwise there is no way to know the location of offscreen indices or handle failures.');\n      onScrollToIndexFailed({\n        averageItemLength: this._averageCellLength,\n        highestMeasuredFrameIndex: this._highestMeasuredFrameIndex,\n        index\n      });\n      return;\n    }\n    const frame = this.__getFrameMetricsApprox(Math.floor(index), this.props);\n    const offset = Math.max(0, this._getOffsetApprox(index, this.props) - (viewPosition || 0) * (this._scrollMetrics.visibleLength - frame.length)) - (viewOffset || 0);\n    if (this._scrollRef == null) {\n      return;\n    }\n    if (this._scrollRef.scrollTo == null) {\n      console.warn('No scrollTo method provided. This may be because you have two nested ' + 'VirtualizedLists with the same orientation, or because you are ' + 'using a custom component that does not implement scrollTo.');\n      return;\n    }\n    this._scrollRef.scrollTo(horizontal ? {\n      x: offset,\n      animated\n    } : {\n      y: offset,\n      animated\n    });\n  }\n  scrollToItem(params) {\n    const {\n      item\n    } = params;\n    const {\n      data,\n      getItem,\n      getItemCount\n    } = this.props;\n    const itemCount = getItemCount(data);\n    for (let index = 0; index < itemCount; index++) {\n      if (getItem(data, index) === item) {\n        this.scrollToIndex(Object.assign({}, params, {\n          index\n        }));\n        break;\n      }\n    }\n  }\n  scrollToOffset(params) {\n    const {\n      animated,\n      offset\n    } = params;\n    if (this._scrollRef == null) {\n      return;\n    }\n    if (this._scrollRef.scrollTo == null) {\n      console.warn('No scrollTo method provided. This may be because you have two nested ' + 'VirtualizedLists with the same orientation, or because you are ' + 'using a custom component that does not implement scrollTo.');\n      return;\n    }\n    this._scrollRef.scrollTo(horizontalOrDefault(this.props.horizontal) ? {\n      x: offset,\n      animated\n    } : {\n      y: offset,\n      animated\n    });\n  }\n  recordInteraction() {\n    this._nestedChildLists.forEach(childList => {\n      childList.recordInteraction();\n    });\n    this._viewabilityTuples.forEach(t => {\n      t.viewabilityHelper.recordInteraction();\n    });\n    this._updateViewableItems(this.props, this.state.cellsAroundViewport);\n  }\n  flashScrollIndicators() {\n    if (this._scrollRef == null) {\n      return;\n    }\n    this._scrollRef.flashScrollIndicators();\n  }\n  getScrollResponder() {\n    if (this._scrollRef && this._scrollRef.getScrollResponder) {\n      return this._scrollRef.getScrollResponder();\n    }\n  }\n  getScrollableNode() {\n    if (this._scrollRef && this._scrollRef.getScrollableNode) {\n      return this._scrollRef.getScrollableNode();\n    } else {\n      return findNodeHandle(this._scrollRef);\n    }\n  }\n  getScrollRef() {\n    if (this._scrollRef && this._scrollRef.getScrollRef) {\n      return this._scrollRef.getScrollRef();\n    } else {\n      return this._scrollRef;\n    }\n  }\n  setNativeProps(props) {\n    if (this._scrollRef) {\n      this._scrollRef.setNativeProps(props);\n    }\n  }\n  _getCellKey() {\n    return this.context?.cellKey || 'rootList';\n  }\n  _getScrollMetrics = () => {\n    return this._scrollMetrics;\n  };\n  hasMore() {\n    return this._hasMore;\n  }\n  _getOutermostParentListRef = () => {\n    if (this._isNestedWithSameOrientation()) {\n      return this.context.getOutermostParentListRef();\n    } else {\n      return this;\n    }\n  };\n  _registerAsNestedChild = childList => {\n    this._nestedChildLists.add(childList.ref, childList.cellKey);\n    if (this._hasInteracted) {\n      childList.ref.recordInteraction();\n    }\n  };\n  _unregisterAsNestedChild = childList => {\n    this._nestedChildLists.remove(childList.ref);\n  };\n  constructor(props) {\n    super(props);\n    this._checkProps(props);\n    this._fillRateHelper = new FillRateHelper(this._getFrameMetrics);\n    this._updateCellsToRenderBatcher = new Batchinator(this._updateCellsToRender, this.props.updateCellsBatchingPeriod ?? 50);\n    if (this.props.viewabilityConfigCallbackPairs) {\n      this._viewabilityTuples = this.props.viewabilityConfigCallbackPairs.map(pair => ({\n        viewabilityHelper: new ViewabilityHelper(pair.viewabilityConfig),\n        onViewableItemsChanged: pair.onViewableItemsChanged\n      }));\n    } else {\n      const {\n        onViewableItemsChanged,\n        viewabilityConfig\n      } = this.props;\n      if (onViewableItemsChanged) {\n        this._viewabilityTuples.push({\n          viewabilityHelper: new ViewabilityHelper(viewabilityConfig),\n          onViewableItemsChanged: onViewableItemsChanged\n        });\n      }\n    }\n    const initialRenderRegion = VirtualizedList._initialRenderRegion(props);\n    const minIndexForVisible = this.props.maintainVisibleContentPosition?.minIndexForVisible ?? 0;\n    this.state = {\n      cellsAroundViewport: initialRenderRegion,\n      renderMask: VirtualizedList._createRenderMask(props, initialRenderRegion),\n      firstVisibleItemKey: this.props.getItemCount(this.props.data) > minIndexForVisible ? VirtualizedList._getItemKey(this.props, minIndexForVisible) : null,\n      pendingScrollUpdateCount: this.props.initialScrollIndex != null && this.props.initialScrollIndex > 0 ? 1 : 0\n    };\n  }\n  _checkProps(props) {\n    const {\n      onScroll,\n      windowSize,\n      getItemCount,\n      data,\n      initialScrollIndex\n    } = props;\n    invariant(!onScroll || !onScroll.__isNative, 'Components based on VirtualizedList must be wrapped with Animated.createAnimatedComponent ' + 'to support native onScroll events with useNativeDriver');\n    invariant(windowSizeOrDefault(windowSize) > 0, 'VirtualizedList: The windowSize prop must be present and set to a value greater than 0.');\n    invariant(getItemCount, 'VirtualizedList: The \"getItemCount\" prop must be provided');\n    const itemCount = getItemCount(data);\n    if (initialScrollIndex != null && !this._hasTriggeredInitialScrollToIndex && (initialScrollIndex < 0 || itemCount > 0 && initialScrollIndex >= itemCount) && !this._hasWarned.initialScrollIndex) {\n      console.warn(`initialScrollIndex \"${initialScrollIndex}\" is not valid (list has ${itemCount} items)`);\n      this._hasWarned.initialScrollIndex = true;\n    }\n    if (__DEV__ && !this._hasWarned.flexWrap) {\n      const flatStyles = StyleSheet.flatten(this.props.contentContainerStyle);\n      if (flatStyles != null && flatStyles.flexWrap === 'wrap') {\n        console.warn('`flexWrap: `wrap`` is not supported with the `VirtualizedList` components.' + 'Consider using `numColumns` with `FlatList` instead.');\n        this._hasWarned.flexWrap = true;\n      }\n    }\n  }\n  static _findItemIndexWithKey(props, key, hint) {\n    const itemCount = props.getItemCount(props.data);\n    if (hint != null && hint >= 0 && hint < itemCount) {\n      const curKey = VirtualizedList._getItemKey(props, hint);\n      if (curKey === key) {\n        return hint;\n      }\n    }\n    for (let ii = 0; ii < itemCount; ii++) {\n      const curKey = VirtualizedList._getItemKey(props, ii);\n      if (curKey === key) {\n        return ii;\n      }\n    }\n    return null;\n  }\n  static _getItemKey(props, index) {\n    const item = props.getItem(props.data, index);\n    return VirtualizedList._keyExtractor(item, index, props);\n  }\n  static _createRenderMask(props, cellsAroundViewport, additionalRegions) {\n    const itemCount = props.getItemCount(props.data);\n    invariant(cellsAroundViewport.first >= 0 && cellsAroundViewport.last >= cellsAroundViewport.first - 1 && cellsAroundViewport.last < itemCount, `Invalid cells around viewport \"[${cellsAroundViewport.first}, ${cellsAroundViewport.last}]\" was passed to VirtualizedList._createRenderMask`);\n    const renderMask = new CellRenderMask(itemCount);\n    if (itemCount > 0) {\n      const allRegions = [cellsAroundViewport, ...(additionalRegions ?? [])];\n      for (const region of allRegions) {\n        renderMask.addCells(region);\n      }\n      if (props.initialScrollIndex == null || props.initialScrollIndex <= 0) {\n        const initialRegion = VirtualizedList._initialRenderRegion(props);\n        renderMask.addCells(initialRegion);\n      }\n      const stickyIndicesSet = new Set(props.stickyHeaderIndices);\n      VirtualizedList._ensureClosestStickyHeader(props, stickyIndicesSet, renderMask, cellsAroundViewport.first);\n    }\n    return renderMask;\n  }\n  static _initialRenderRegion(props) {\n    const itemCount = props.getItemCount(props.data);\n    const firstCellIndex = Math.max(0, Math.min(itemCount - 1, Math.floor(props.initialScrollIndex ?? 0)));\n    const lastCellIndex = Math.min(itemCount, firstCellIndex + initialNumToRenderOrDefault(props.initialNumToRender)) - 1;\n    return {\n      first: firstCellIndex,\n      last: lastCellIndex\n    };\n  }\n  static _ensureClosestStickyHeader(props, stickyIndicesSet, renderMask, cellIdx) {\n    const stickyOffset = props.ListHeaderComponent ? 1 : 0;\n    for (let itemIdx = cellIdx - 1; itemIdx >= 0; itemIdx--) {\n      if (stickyIndicesSet.has(itemIdx + stickyOffset)) {\n        renderMask.addCells({\n          first: itemIdx,\n          last: itemIdx\n        });\n        break;\n      }\n    }\n  }\n  _adjustCellsAroundViewport(props, cellsAroundViewport, pendingScrollUpdateCount) {\n    const {\n      data,\n      getItemCount\n    } = props;\n    const onEndReachedThreshold = onEndReachedThresholdOrDefault(props.onEndReachedThreshold);\n    const {\n      contentLength,\n      offset,\n      visibleLength\n    } = this._scrollMetrics;\n    const distanceFromEnd = contentLength - visibleLength - offset;\n    if (visibleLength <= 0 || contentLength <= 0) {\n      return cellsAroundViewport.last >= getItemCount(data) ? VirtualizedList._constrainToItemCount(cellsAroundViewport, props) : cellsAroundViewport;\n    }\n    let newCellsAroundViewport;\n    if (props.disableVirtualization) {\n      const renderAhead = distanceFromEnd < onEndReachedThreshold * visibleLength ? maxToRenderPerBatchOrDefault(props.maxToRenderPerBatch) : 0;\n      newCellsAroundViewport = {\n        first: 0,\n        last: Math.min(cellsAroundViewport.last + renderAhead, getItemCount(data) - 1)\n      };\n    } else {\n      if (pendingScrollUpdateCount > 0) {\n        return cellsAroundViewport.last >= getItemCount(data) ? VirtualizedList._constrainToItemCount(cellsAroundViewport, props) : cellsAroundViewport;\n      }\n      newCellsAroundViewport = computeWindowedRenderLimits(props, maxToRenderPerBatchOrDefault(props.maxToRenderPerBatch), windowSizeOrDefault(props.windowSize), cellsAroundViewport, this.__getFrameMetricsApprox, this._scrollMetrics);\n      invariant(newCellsAroundViewport.last < getItemCount(data), 'computeWindowedRenderLimits() should return range in-bounds');\n    }\n    if (this._nestedChildLists.size() > 0) {\n      const childIdx = this._findFirstChildWithMore(newCellsAroundViewport.first, newCellsAroundViewport.last);\n      newCellsAroundViewport.last = childIdx ?? newCellsAroundViewport.last;\n    }\n    return newCellsAroundViewport;\n  }\n  _findFirstChildWithMore(first, last) {\n    for (let ii = first; ii <= last; ii++) {\n      const cellKeyForIndex = this._indicesToKeys.get(ii);\n      if (cellKeyForIndex != null && this._nestedChildLists.anyInCell(cellKeyForIndex, childList => childList.hasMore())) {\n        return ii;\n      }\n    }\n    return null;\n  }\n  componentDidMount() {\n    if (this._isNestedWithSameOrientation()) {\n      this.context.registerAsNestedChild({\n        ref: this,\n        cellKey: this.context.cellKey\n      });\n    }\n  }\n  componentWillUnmount() {\n    if (this._isNestedWithSameOrientation()) {\n      this.context.unregisterAsNestedChild({\n        ref: this\n      });\n    }\n    this._updateCellsToRenderBatcher.dispose({\n      abort: true\n    });\n    this._viewabilityTuples.forEach(tuple => {\n      tuple.viewabilityHelper.dispose();\n    });\n    this._fillRateHelper.deactivateAndFlush();\n  }\n  static getDerivedStateFromProps(newProps, prevState) {\n    const itemCount = newProps.getItemCount(newProps.data);\n    if (itemCount === prevState.renderMask.numCells()) {\n      return prevState;\n    }\n    let maintainVisibleContentPositionAdjustment = null;\n    const prevFirstVisibleItemKey = prevState.firstVisibleItemKey;\n    const minIndexForVisible = newProps.maintainVisibleContentPosition?.minIndexForVisible ?? 0;\n    const newFirstVisibleItemKey = newProps.getItemCount(newProps.data) > minIndexForVisible ? VirtualizedList._getItemKey(newProps, minIndexForVisible) : null;\n    if (newProps.maintainVisibleContentPosition != null && prevFirstVisibleItemKey != null && newFirstVisibleItemKey != null) {\n      if (newFirstVisibleItemKey !== prevFirstVisibleItemKey) {\n        const hint = itemCount - prevState.renderMask.numCells() + minIndexForVisible;\n        const firstVisibleItemIndex = VirtualizedList._findItemIndexWithKey(newProps, prevFirstVisibleItemKey, hint);\n        maintainVisibleContentPositionAdjustment = firstVisibleItemIndex != null ? firstVisibleItemIndex - minIndexForVisible : null;\n      } else {\n        maintainVisibleContentPositionAdjustment = null;\n      }\n    }\n    const constrainedCells = VirtualizedList._constrainToItemCount(maintainVisibleContentPositionAdjustment != null ? {\n      first: prevState.cellsAroundViewport.first + maintainVisibleContentPositionAdjustment,\n      last: prevState.cellsAroundViewport.last + maintainVisibleContentPositionAdjustment\n    } : prevState.cellsAroundViewport, newProps);\n    return {\n      cellsAroundViewport: constrainedCells,\n      renderMask: VirtualizedList._createRenderMask(newProps, constrainedCells),\n      firstVisibleItemKey: newFirstVisibleItemKey,\n      pendingScrollUpdateCount: maintainVisibleContentPositionAdjustment != null ? prevState.pendingScrollUpdateCount + 1 : prevState.pendingScrollUpdateCount\n    };\n  }\n  _pushCells(cells, stickyHeaderIndices, stickyIndicesFromProps, first, last, inversionStyle) {\n    const {\n      CellRendererComponent,\n      ItemSeparatorComponent,\n      ListHeaderComponent,\n      ListItemComponent,\n      data,\n      debug,\n      getItem,\n      getItemCount,\n      getItemLayout,\n      horizontal,\n      renderItem\n    } = this.props;\n    const stickyOffset = ListHeaderComponent ? 1 : 0;\n    const end = getItemCount(data) - 1;\n    let prevCellKey;\n    last = Math.min(end, last);\n    for (let ii = first; ii <= last; ii++) {\n      const item = getItem(data, ii);\n      const key = VirtualizedList._keyExtractor(item, ii, this.props);\n      this._indicesToKeys.set(ii, key);\n      if (stickyIndicesFromProps.has(ii + stickyOffset)) {\n        stickyHeaderIndices.push(cells.length);\n      }\n      const shouldListenForLayout = getItemLayout == null || debug || this._fillRateHelper.enabled();\n      cells.push(_jsxDEV(CellRenderer, Object.assign({\n        CellRendererComponent: CellRendererComponent,\n        ItemSeparatorComponent: ii < end ? ItemSeparatorComponent : undefined,\n        ListItemComponent: ListItemComponent,\n        cellKey: key,\n        horizontal: horizontal,\n        index: ii,\n        inversionStyle: inversionStyle,\n        item: item,\n        prevCellKey: prevCellKey,\n        onUpdateSeparators: this._onUpdateSeparators,\n        onCellFocusCapture: e => this._onCellFocusCapture(key),\n        onUnmount: this._onCellUnmount,\n        ref: ref => {\n          this._cellRefs[key] = ref;\n        },\n        renderItem: renderItem\n      }, shouldListenForLayout && {\n        onCellLayout: this._onCellLayout\n      }), key, false, {\n        fileName: _jsxFileName,\n        lineNumber: 853,\n        columnNumber: 9\n      }, this));\n      prevCellKey = key;\n    }\n  }\n  static _constrainToItemCount(cells, props) {\n    const itemCount = props.getItemCount(props.data);\n    const last = Math.min(itemCount - 1, cells.last);\n    const maxToRenderPerBatch = maxToRenderPerBatchOrDefault(props.maxToRenderPerBatch);\n    return {\n      first: clamp(0, itemCount - 1 - maxToRenderPerBatch, cells.first),\n      last\n    };\n  }\n  _onUpdateSeparators = (keys, newProps) => {\n    keys.forEach(key => {\n      const ref = key != null && this._cellRefs[key];\n      ref && ref.updateSeparatorProps(newProps);\n    });\n  };\n  _isNestedWithSameOrientation() {\n    const nestedContext = this.context;\n    return !!(nestedContext && !!nestedContext.horizontal === horizontalOrDefault(this.props.horizontal));\n  }\n  _getSpacerKey = isVertical => isVertical ? 'height' : 'width';\n  static _keyExtractor(item, index, props) {\n    if (props.keyExtractor != null) {\n      return props.keyExtractor(item, index);\n    }\n    const key = defaultKeyExtractor(item, index);\n    if (key === String(index)) {\n      _usedIndexForKey = true;\n      if (item.type && item.type.displayName) {\n        _keylessItemComponentName = item.type.displayName;\n      }\n    }\n    return key;\n  }\n  render() {\n    this._checkProps(this.props);\n    const {\n      ListEmptyComponent,\n      ListFooterComponent,\n      ListHeaderComponent\n    } = this.props;\n    const {\n      data,\n      horizontal\n    } = this.props;\n    const inversionStyle = this.props.inverted ? horizontalOrDefault(this.props.horizontal) ? styles.horizontallyInverted : styles.verticallyInverted : null;\n    const cells = [];\n    const stickyIndicesFromProps = new Set(this.props.stickyHeaderIndices);\n    const stickyHeaderIndices = [];\n    if (ListHeaderComponent) {\n      if (stickyIndicesFromProps.has(0)) {\n        stickyHeaderIndices.push(0);\n      }\n      const element = React.isValidElement(ListHeaderComponent) ? ListHeaderComponent : _jsxDEV(ListHeaderComponent, {}, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 961,\n        columnNumber: 9\n      }, this);\n      cells.push(_jsxDEV(VirtualizedListCellContextProvider, {\n        cellKey: this._getCellKey() + '-header',\n        children: _jsxDEV(View, {\n          collapsable: false,\n          onLayout: this._onLayoutHeader,\n          style: StyleSheet.compose(inversionStyle, this.props.ListHeaderComponentStyle),\n          children: element\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 967,\n          columnNumber: 11\n        }, this)\n      }, \"$header\", false, {\n        fileName: _jsxFileName,\n        lineNumber: 964,\n        columnNumber: 9\n      }, this));\n    }\n    const itemCount = this.props.getItemCount(data);\n    if (itemCount === 0 && ListEmptyComponent) {\n      const element = React.isValidElement(ListEmptyComponent) ? ListEmptyComponent : _jsxDEV(ListEmptyComponent, {}, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 996,\n        columnNumber: 9\n      }, this);\n      cells.push(_jsxDEV(VirtualizedListCellContextProvider, {\n        cellKey: this._getCellKey() + '-empty',\n        children: React.cloneElement(element, {\n          onLayout: event => {\n            this._onLayoutEmpty(event);\n            if (element.props.onLayout) {\n              element.props.onLayout(event);\n            }\n          },\n          style: StyleSheet.compose(inversionStyle, element.props.style)\n        })\n      }, \"$empty\", false, {\n        fileName: _jsxFileName,\n        lineNumber: 999,\n        columnNumber: 9\n      }, this));\n    }\n    if (itemCount > 0) {\n      _usedIndexForKey = false;\n      _keylessItemComponentName = '';\n      const spacerKey = this._getSpacerKey(!horizontal);\n      const renderRegions = this.state.renderMask.enumerateRegions();\n      const lastSpacer = findLastWhere(renderRegions, r => r.isSpacer);\n      for (const section of renderRegions) {\n        if (section.isSpacer) {\n          if (this.props.disableVirtualization) {\n            continue;\n          }\n          const isLastSpacer = section === lastSpacer;\n          const constrainToMeasured = isLastSpacer && !this.props.getItemLayout;\n          const last = constrainToMeasured ? clamp(section.first - 1, section.last, this._highestMeasuredFrameIndex) : section.last;\n          const firstMetrics = this.__getFrameMetricsApprox(section.first, this.props);\n          const lastMetrics = this.__getFrameMetricsApprox(last, this.props);\n          const spacerSize = lastMetrics.offset + lastMetrics.length - firstMetrics.offset;\n          cells.push(_jsxDEV(View, {\n            style: {\n              [spacerKey]: spacerSize\n            }\n          }, `$spacer-${section.first}`, false, {\n            fileName: _jsxFileName,\n            lineNumber: 1053,\n            columnNumber: 13\n          }, this));\n        } else {\n          this._pushCells(cells, stickyHeaderIndices, stickyIndicesFromProps, section.first, section.last, inversionStyle);\n        }\n      }\n      if (!this._hasWarned.keys && _usedIndexForKey) {\n        console.warn('VirtualizedList: missing keys for items, make sure to specify a key or id property on each ' + 'item or provide a custom keyExtractor.', _keylessItemComponentName);\n        this._hasWarned.keys = true;\n      }\n    }\n    if (ListFooterComponent) {\n      const element = React.isValidElement(ListFooterComponent) ? ListFooterComponent : _jsxDEV(ListFooterComponent, {}, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 1087,\n        columnNumber: 9\n      }, this);\n      cells.push(_jsxDEV(VirtualizedListCellContextProvider, {\n        cellKey: this._getFooterCellKey(),\n        children: _jsxDEV(View, {\n          onLayout: this._onLayoutFooter,\n          style: StyleSheet.compose(inversionStyle, this.props.ListFooterComponentStyle),\n          children: element\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 1093,\n          columnNumber: 11\n        }, this)\n      }, \"$footer\", false, {\n        fileName: _jsxFileName,\n        lineNumber: 1090,\n        columnNumber: 9\n      }, this));\n    }\n    const scrollProps = Object.assign({}, this.props, {\n      onContentSizeChange: this._onContentSizeChange,\n      onLayout: this._onLayout,\n      onScroll: this._onScroll,\n      onScrollBeginDrag: this._onScrollBeginDrag,\n      onScrollEndDrag: this._onScrollEndDrag,\n      onMomentumScrollBegin: this._onMomentumScrollBegin,\n      onMomentumScrollEnd: this._onMomentumScrollEnd,\n      scrollEventThrottle: scrollEventThrottleOrDefault(this.props.scrollEventThrottle),\n      invertStickyHeaders: this.props.invertStickyHeaders !== undefined ? this.props.invertStickyHeaders : this.props.inverted,\n      stickyHeaderIndices,\n      style: inversionStyle ? [inversionStyle, this.props.style] : this.props.style,\n      isInvertedVirtualizedList: this.props.inverted,\n      maintainVisibleContentPosition: this.props.maintainVisibleContentPosition != null ? Object.assign({}, this.props.maintainVisibleContentPosition, {\n        minIndexForVisible: this.props.maintainVisibleContentPosition.minIndexForVisible + (this.props.ListHeaderComponent ? 1 : 0)\n      }) : undefined\n    });\n    this._hasMore = this.state.cellsAroundViewport.last < itemCount - 1;\n    const innerRet = _jsxDEV(VirtualizedListContextProvider, {\n      value: {\n        cellKey: null,\n        getScrollMetrics: this._getScrollMetrics,\n        horizontal: horizontalOrDefault(this.props.horizontal),\n        getOutermostParentListRef: this._getOutermostParentListRef,\n        registerAsNestedChild: this._registerAsNestedChild,\n        unregisterAsNestedChild: this._unregisterAsNestedChild\n      },\n      children: React.cloneElement((this.props.renderScrollComponent || this._defaultRenderScrollComponent)(scrollProps), {\n        ref: this._captureScrollRef\n      }, cells)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 1145,\n      columnNumber: 7\n    }, this);\n    let ret = innerRet;\n    if (__DEV__) {\n      ret = _jsxDEV(ScrollView.Context.Consumer, {\n        children: scrollContext => {\n          if (scrollContext != null && !scrollContext.horizontal === !horizontalOrDefault(this.props.horizontal) && !this._hasWarned.nesting && this.context == null && this.props.scrollEnabled !== false) {\n            console.error('VirtualizedLists should never be nested inside plain ScrollViews with the same ' + 'orientation because it can break windowing and other functionality - use another ' + 'VirtualizedList-backed container instead.');\n            this._hasWarned.nesting = true;\n          }\n          return innerRet;\n        }\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 1169,\n        columnNumber: 9\n      }, this);\n    }\n    if (this.props.debug) {\n      return _jsxDEV(View, {\n        style: styles.debug,\n        children: [ret, this._renderDebugOverlay()]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 1194,\n        columnNumber: 9\n      }, this);\n    } else {\n      return ret;\n    }\n  }\n  componentDidUpdate(prevProps) {\n    const {\n      data,\n      extraData\n    } = this.props;\n    if (data !== prevProps.data || extraData !== prevProps.extraData) {\n      this._viewabilityTuples.forEach(tuple => {\n        tuple.viewabilityHelper.resetViewableIndices();\n      });\n    }\n    const hiPriInProgress = this._hiPriInProgress;\n    this._scheduleCellsToRenderUpdate();\n    if (hiPriInProgress) {\n      this._hiPriInProgress = false;\n    }\n  }\n  _averageCellLength = 0;\n  _cellRefs = {};\n  _frames = {};\n  _footerLength = 0;\n  _hasTriggeredInitialScrollToIndex = false;\n  _hasInteracted = false;\n  _hasMore = false;\n  _hasWarned = {};\n  _headerLength = 0;\n  _hiPriInProgress = false;\n  _highestMeasuredFrameIndex = 0;\n  _indicesToKeys = new Map();\n  _lastFocusedCellKey = null;\n  _nestedChildLists = new ChildListCollection();\n  _offsetFromParentVirtualizedList = 0;\n  _prevParentOffset = 0;\n  _scrollMetrics = {\n    contentLength: 0,\n    dOffset: 0,\n    dt: 10,\n    offset: 0,\n    timestamp: 0,\n    velocity: 0,\n    visibleLength: 0,\n    zoomScale: 1\n  };\n  _scrollRef = null;\n  _sentStartForContentLength = 0;\n  _sentEndForContentLength = 0;\n  _totalCellLength = 0;\n  _totalCellsMeasured = 0;\n  _viewabilityTuples = [];\n  _captureScrollRef = ref => {\n    this._scrollRef = ref;\n  };\n  _computeBlankness() {\n    this._fillRateHelper.computeBlankness(this.props, this.state.cellsAroundViewport, this._scrollMetrics);\n  }\n  _defaultRenderScrollComponent = props => {\n    const onRefresh = props.onRefresh;\n    if (this._isNestedWithSameOrientation()) {\n      return _jsxDEV(View, Object.assign({}, props), void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 1293,\n        columnNumber: 14\n      }, this);\n    } else if (onRefresh) {\n      invariant(typeof props.refreshing === 'boolean', '`refreshing` prop must be set as a boolean in order to use `onRefresh`, but got `' + JSON.stringify(props.refreshing ?? 'undefined') + '`');\n      return (_jsxDEV(ScrollView, Object.assign({}, props, {\n          refreshControl: props.refreshControl == null ? _jsxDEV(RefreshControl, {\n            refreshing: props.refreshing,\n            onRefresh: onRefresh,\n            progressViewOffset: props.progressViewOffset\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 1308,\n            columnNumber: 15\n          }, this) : props.refreshControl\n        }), void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 1304,\n          columnNumber: 9\n        }, this)\n      );\n    } else {\n      return _jsxDEV(ScrollView, Object.assign({}, props), void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 1323,\n        columnNumber: 14\n      }, this);\n    }\n  };\n  _onCellLayout = (e, cellKey, index) => {\n    const layout = e.nativeEvent.layout;\n    const next = {\n      offset: this._selectOffset(layout),\n      length: this._selectLength(layout),\n      index,\n      inLayout: true\n    };\n    const curr = this._frames[cellKey];\n    if (!curr || next.offset !== curr.offset || next.length !== curr.length || index !== curr.index) {\n      this._totalCellLength += next.length - (curr ? curr.length : 0);\n      this._totalCellsMeasured += curr ? 0 : 1;\n      this._averageCellLength = this._totalCellLength / this._totalCellsMeasured;\n      this._frames[cellKey] = next;\n      this._highestMeasuredFrameIndex = Math.max(this._highestMeasuredFrameIndex, index);\n      this._scheduleCellsToRenderUpdate();\n    } else {\n      this._frames[cellKey].inLayout = true;\n    }\n    this._triggerRemeasureForChildListsInCell(cellKey);\n    this._computeBlankness();\n    this._updateViewableItems(this.props, this.state.cellsAroundViewport);\n  };\n  _onCellFocusCapture(cellKey) {\n    this._lastFocusedCellKey = cellKey;\n    this._updateCellsToRender();\n  }\n  _onCellUnmount = cellKey => {\n    delete this._cellRefs[cellKey];\n    const curr = this._frames[cellKey];\n    if (curr) {\n      this._frames[cellKey] = Object.assign({}, curr, {\n        inLayout: false\n      });\n    }\n  };\n  _triggerRemeasureForChildListsInCell(cellKey) {\n    this._nestedChildLists.forEachInCell(cellKey, childList => {\n      childList.measureLayoutRelativeToContainingList();\n    });\n  }\n  measureLayoutRelativeToContainingList() {\n    try {\n      if (!this._scrollRef) {\n        return;\n      }\n      this._scrollRef.measureLayout(this.context.getOutermostParentListRef().getScrollRef(), (x, y, width, height) => {\n        this._offsetFromParentVirtualizedList = this._selectOffset({\n          x,\n          y\n        });\n        this._scrollMetrics.contentLength = this._selectLength({\n          width,\n          height\n        });\n        const scrollMetrics = this._convertParentScrollMetrics(this.context.getScrollMetrics());\n        const metricsChanged = this._scrollMetrics.visibleLength !== scrollMetrics.visibleLength || this._scrollMetrics.offset !== scrollMetrics.offset;\n        if (metricsChanged) {\n          this._scrollMetrics.visibleLength = scrollMetrics.visibleLength;\n          this._scrollMetrics.offset = scrollMetrics.offset;\n          this._nestedChildLists.forEach(childList => {\n            childList.measureLayoutRelativeToContainingList();\n          });\n        }\n      }, error => {\n        console.warn(\"VirtualizedList: Encountered an error while measuring a list's\" + ' offset from its containing VirtualizedList.');\n      });\n    } catch (error) {\n      console.warn('measureLayoutRelativeToContainingList threw an error', error.stack);\n    }\n  }\n  _onLayout = e => {\n    if (this._isNestedWithSameOrientation()) {\n      this.measureLayoutRelativeToContainingList();\n    } else {\n      this._scrollMetrics.visibleLength = this._selectLength(e.nativeEvent.layout);\n    }\n    this.props.onLayout && this.props.onLayout(e);\n    this._scheduleCellsToRenderUpdate();\n    this._maybeCallOnEdgeReached();\n  };\n  _onLayoutEmpty = e => {\n    this.props.onLayout && this.props.onLayout(e);\n  };\n  _getFooterCellKey() {\n    return this._getCellKey() + '-footer';\n  }\n  _onLayoutFooter = e => {\n    this._triggerRemeasureForChildListsInCell(this._getFooterCellKey());\n    this._footerLength = this._selectLength(e.nativeEvent.layout);\n  };\n  _onLayoutHeader = e => {\n    this._headerLength = this._selectLength(e.nativeEvent.layout);\n  };\n  _renderDebugOverlay() {\n    const normalize = this._scrollMetrics.visibleLength / (this._scrollMetrics.contentLength || 1);\n    const framesInLayout = [];\n    const itemCount = this.props.getItemCount(this.props.data);\n    for (let ii = 0; ii < itemCount; ii++) {\n      const frame = this.__getFrameMetricsApprox(ii, this.props);\n      if (frame.inLayout) {\n        framesInLayout.push(frame);\n      }\n    }\n    const windowTop = this.__getFrameMetricsApprox(this.state.cellsAroundViewport.first, this.props).offset;\n    const frameLast = this.__getFrameMetricsApprox(this.state.cellsAroundViewport.last, this.props);\n    const windowLen = frameLast.offset + frameLast.length - windowTop;\n    const visTop = this._scrollMetrics.offset;\n    const visLen = this._scrollMetrics.visibleLength;\n    return _jsxDEV(View, {\n      style: [styles.debugOverlayBase, styles.debugOverlay],\n      children: [framesInLayout.map((f, ii) => _jsxDEV(View, {\n        style: [styles.debugOverlayBase, styles.debugOverlayFrame, {\n          top: f.offset * normalize,\n          height: f.length * normalize\n        }]\n      }, 'f' + ii, false, {\n        fileName: _jsxFileName,\n        lineNumber: 1495,\n        columnNumber: 11\n      }, this)), _jsxDEV(View, {\n        style: [styles.debugOverlayBase, styles.debugOverlayFrameLast, {\n          top: windowTop * normalize,\n          height: windowLen * normalize\n        }]\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 1507,\n        columnNumber: 9\n      }, this), _jsxDEV(View, {\n        style: [styles.debugOverlayBase, styles.debugOverlayFrameVis, {\n          top: visTop * normalize,\n          height: visLen * normalize\n        }]\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 1517,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 1493,\n      columnNumber: 7\n    }, this);\n  }\n  _selectLength(metrics) {\n    return !horizontalOrDefault(this.props.horizontal) ? metrics.height : metrics.width;\n  }\n  _selectOffset(metrics) {\n    return !horizontalOrDefault(this.props.horizontal) ? metrics.y : metrics.x;\n  }\n  _maybeCallOnEdgeReached() {\n    const {\n      data,\n      getItemCount,\n      onStartReached,\n      onStartReachedThreshold,\n      onEndReached,\n      onEndReachedThreshold\n    } = this.props;\n    if (this.state.pendingScrollUpdateCount > 0) {\n      return;\n    }\n    const {\n      contentLength,\n      visibleLength,\n      offset\n    } = this._scrollMetrics;\n    let distanceFromStart = offset;\n    let distanceFromEnd = contentLength - visibleLength - offset;\n    if (distanceFromStart < ON_EDGE_REACHED_EPSILON) {\n      distanceFromStart = 0;\n    }\n    if (distanceFromEnd < ON_EDGE_REACHED_EPSILON) {\n      distanceFromEnd = 0;\n    }\n    const DEFAULT_THRESHOLD_PX = 2;\n    const startThreshold = onStartReachedThreshold != null ? onStartReachedThreshold * visibleLength : DEFAULT_THRESHOLD_PX;\n    const endThreshold = onEndReachedThreshold != null ? onEndReachedThreshold * visibleLength : DEFAULT_THRESHOLD_PX;\n    const isWithinStartThreshold = distanceFromStart <= startThreshold;\n    const isWithinEndThreshold = distanceFromEnd <= endThreshold;\n    if (onEndReached && this.state.cellsAroundViewport.last === getItemCount(data) - 1 && isWithinEndThreshold && this._scrollMetrics.contentLength !== this._sentEndForContentLength) {\n      this._sentEndForContentLength = this._scrollMetrics.contentLength;\n      onEndReached({\n        distanceFromEnd\n      });\n    } else if (onStartReached != null && this.state.cellsAroundViewport.first === 0 && isWithinStartThreshold && this._scrollMetrics.contentLength !== this._sentStartForContentLength) {\n      this._sentStartForContentLength = this._scrollMetrics.contentLength;\n      onStartReached({\n        distanceFromStart\n      });\n    } else {\n      this._sentStartForContentLength = isWithinStartThreshold ? this._sentStartForContentLength : 0;\n      this._sentEndForContentLength = isWithinEndThreshold ? this._sentEndForContentLength : 0;\n    }\n  }\n  _onContentSizeChange = (width, height) => {\n    if (width > 0 && height > 0 && this.props.initialScrollIndex != null && this.props.initialScrollIndex > 0 && !this._hasTriggeredInitialScrollToIndex) {\n      if (this.props.contentOffset == null) {\n        if (this.props.initialScrollIndex < this.props.getItemCount(this.props.data)) {\n          this.scrollToIndex({\n            animated: false,\n            index: nullthrows(this.props.initialScrollIndex)\n          });\n        } else {\n          this.scrollToEnd({\n            animated: false\n          });\n        }\n      }\n      this._hasTriggeredInitialScrollToIndex = true;\n    }\n    if (this.props.onContentSizeChange) {\n      this.props.onContentSizeChange(width, height);\n    }\n    this._scrollMetrics.contentLength = this._selectLength({\n      height,\n      width\n    });\n    this._scheduleCellsToRenderUpdate();\n    this._maybeCallOnEdgeReached();\n  };\n  _convertParentScrollMetrics = metrics => {\n    const offset = metrics.offset - this._offsetFromParentVirtualizedList;\n    const visibleLength = metrics.visibleLength;\n    const dOffset = offset - this._scrollMetrics.offset;\n    const contentLength = this._scrollMetrics.contentLength;\n    return {\n      visibleLength,\n      contentLength,\n      offset,\n      dOffset\n    };\n  };\n  _onScroll = e => {\n    this._nestedChildLists.forEach(childList => {\n      childList._onScroll(e);\n    });\n    if (this.props.onScroll) {\n      this.props.onScroll(e);\n    }\n    const timestamp = e.timeStamp;\n    let visibleLength = this._selectLength(e.nativeEvent.layoutMeasurement);\n    let contentLength = this._selectLength(e.nativeEvent.contentSize);\n    let offset = this._selectOffset(e.nativeEvent.contentOffset);\n    let dOffset = offset - this._scrollMetrics.offset;\n    if (this._isNestedWithSameOrientation()) {\n      if (this._scrollMetrics.contentLength === 0) {\n        return;\n      }\n      ({\n        visibleLength,\n        contentLength,\n        offset,\n        dOffset\n      } = this._convertParentScrollMetrics({\n        visibleLength,\n        offset\n      }));\n    }\n    const dt = this._scrollMetrics.timestamp ? Math.max(1, timestamp - this._scrollMetrics.timestamp) : 1;\n    const velocity = dOffset / dt;\n    if (dt > 500 && this._scrollMetrics.dt > 500 && contentLength > 5 * visibleLength && !this._hasWarned.perf) {\n      infoLog('VirtualizedList: You have a large list that is slow to update - make sure your ' + 'renderItem function renders components that follow React performance best practices ' + 'like PureComponent, shouldComponentUpdate, etc.', {\n        dt,\n        prevDt: this._scrollMetrics.dt,\n        contentLength\n      });\n      this._hasWarned.perf = true;\n    }\n    const zoomScale = e.nativeEvent.zoomScale < 0 ? 1 : e.nativeEvent.zoomScale;\n    this._scrollMetrics = {\n      contentLength,\n      dt,\n      dOffset,\n      offset,\n      timestamp,\n      velocity,\n      visibleLength,\n      zoomScale\n    };\n    if (this.state.pendingScrollUpdateCount > 0) {\n      this.setState(state => ({\n        pendingScrollUpdateCount: state.pendingScrollUpdateCount - 1\n      }));\n    }\n    this._updateViewableItems(this.props, this.state.cellsAroundViewport);\n    if (!this.props) {\n      return;\n    }\n    this._maybeCallOnEdgeReached();\n    if (velocity !== 0) {\n      this._fillRateHelper.activate();\n    }\n    this._computeBlankness();\n    this._scheduleCellsToRenderUpdate();\n  };\n  _scheduleCellsToRenderUpdate() {\n    const {\n      first,\n      last\n    } = this.state.cellsAroundViewport;\n    const {\n      offset,\n      visibleLength,\n      velocity\n    } = this._scrollMetrics;\n    const itemCount = this.props.getItemCount(this.props.data);\n    let hiPri = false;\n    const onStartReachedThreshold = onStartReachedThresholdOrDefault(this.props.onStartReachedThreshold);\n    const onEndReachedThreshold = onEndReachedThresholdOrDefault(this.props.onEndReachedThreshold);\n    if (first > 0) {\n      const distTop = offset - this.__getFrameMetricsApprox(first, this.props).offset;\n      hiPri = distTop < 0 || velocity < -2 && distTop < getScrollingThreshold(onStartReachedThreshold, visibleLength);\n    }\n    if (!hiPri && last >= 0 && last < itemCount - 1) {\n      const distBottom = this.__getFrameMetricsApprox(last, this.props).offset - (offset + visibleLength);\n      hiPri = distBottom < 0 || velocity > 2 && distBottom < getScrollingThreshold(onEndReachedThreshold, visibleLength);\n    }\n    if (hiPri && (this._averageCellLength || this.props.getItemLayout) && !this._hiPriInProgress) {\n      this._hiPriInProgress = true;\n      this._updateCellsToRenderBatcher.dispose({\n        abort: true\n      });\n      this._updateCellsToRender();\n      return;\n    } else {\n      this._updateCellsToRenderBatcher.schedule();\n    }\n  }\n  _onScrollBeginDrag = e => {\n    this._nestedChildLists.forEach(childList => {\n      childList._onScrollBeginDrag(e);\n    });\n    this._viewabilityTuples.forEach(tuple => {\n      tuple.viewabilityHelper.recordInteraction();\n    });\n    this._hasInteracted = true;\n    this.props.onScrollBeginDrag && this.props.onScrollBeginDrag(e);\n  };\n  _onScrollEndDrag = e => {\n    this._nestedChildLists.forEach(childList => {\n      childList._onScrollEndDrag(e);\n    });\n    const {\n      velocity\n    } = e.nativeEvent;\n    if (velocity) {\n      this._scrollMetrics.velocity = this._selectOffset(velocity);\n    }\n    this._computeBlankness();\n    this.props.onScrollEndDrag && this.props.onScrollEndDrag(e);\n  };\n  _onMomentumScrollBegin = e => {\n    this._nestedChildLists.forEach(childList => {\n      childList._onMomentumScrollBegin(e);\n    });\n    this.props.onMomentumScrollBegin && this.props.onMomentumScrollBegin(e);\n  };\n  _onMomentumScrollEnd = e => {\n    this._nestedChildLists.forEach(childList => {\n      childList._onMomentumScrollEnd(e);\n    });\n    this._scrollMetrics.velocity = 0;\n    this._computeBlankness();\n    this.props.onMomentumScrollEnd && this.props.onMomentumScrollEnd(e);\n  };\n  _updateCellsToRender = () => {\n    this._updateViewableItems(this.props, this.state.cellsAroundViewport);\n    this.setState((state, props) => {\n      const cellsAroundViewport = this._adjustCellsAroundViewport(props, state.cellsAroundViewport, state.pendingScrollUpdateCount);\n      const renderMask = VirtualizedList._createRenderMask(props, cellsAroundViewport, this._getNonViewportRenderRegions(props));\n      if (cellsAroundViewport.first === state.cellsAroundViewport.first && cellsAroundViewport.last === state.cellsAroundViewport.last && renderMask.equals(state.renderMask)) {\n        return null;\n      }\n      return {\n        cellsAroundViewport,\n        renderMask\n      };\n    });\n  };\n  _createViewToken = (index, isViewable, props) => {\n    const {\n      data,\n      getItem\n    } = props;\n    const item = getItem(data, index);\n    return {\n      index,\n      item,\n      key: VirtualizedList._keyExtractor(item, index, props),\n      isViewable\n    };\n  };\n  _getOffsetApprox = (index, props) => {\n    if (Number.isInteger(index)) {\n      return this.__getFrameMetricsApprox(index, props).offset;\n    } else {\n      const frameMetrics = this.__getFrameMetricsApprox(Math.floor(index), props);\n      const remainder = index - Math.floor(index);\n      return frameMetrics.offset + remainder * frameMetrics.length;\n    }\n  };\n  __getFrameMetricsApprox = (index, props) => {\n    const frame = this._getFrameMetrics(index, props);\n    if (frame && frame.index === index) {\n      return frame;\n    } else {\n      const {\n        data,\n        getItemCount,\n        getItemLayout\n      } = props;\n      invariant(index >= 0 && index < getItemCount(data), 'Tried to get frame for out of range index ' + index);\n      invariant(!getItemLayout, 'Should not have to estimate frames when a measurement metrics function is provided');\n      return {\n        length: this._averageCellLength,\n        offset: this._averageCellLength * index\n      };\n    }\n  };\n  _getFrameMetrics = (index, props) => {\n    const {\n      data,\n      getItemCount,\n      getItemLayout\n    } = props;\n    invariant(index >= 0 && index < getItemCount(data), 'Tried to get frame for out of range index ' + index);\n    const frame = this._frames[VirtualizedList._getItemKey(props, index)];\n    if (!frame || frame.index !== index) {\n      if (getItemLayout) {\n        return getItemLayout(data, index);\n      }\n    }\n    return frame;\n  };\n  _getNonViewportRenderRegions = props => {\n    if (!(this._lastFocusedCellKey && this._cellRefs[this._lastFocusedCellKey])) {\n      return [];\n    }\n    const lastFocusedCellRenderer = this._cellRefs[this._lastFocusedCellKey];\n    const focusedCellIndex = lastFocusedCellRenderer.props.index;\n    const itemCount = props.getItemCount(props.data);\n    if (focusedCellIndex >= itemCount || VirtualizedList._getItemKey(props, focusedCellIndex) !== this._lastFocusedCellKey) {\n      return [];\n    }\n    let first = focusedCellIndex;\n    let heightOfCellsBeforeFocused = 0;\n    for (let i = first - 1; i >= 0 && heightOfCellsBeforeFocused < this._scrollMetrics.visibleLength; i--) {\n      first--;\n      heightOfCellsBeforeFocused += this.__getFrameMetricsApprox(i, props).length;\n    }\n    let last = focusedCellIndex;\n    let heightOfCellsAfterFocused = 0;\n    for (let i = last + 1; i < itemCount && heightOfCellsAfterFocused < this._scrollMetrics.visibleLength; i++) {\n      last++;\n      heightOfCellsAfterFocused += this.__getFrameMetricsApprox(i, props).length;\n    }\n    return [{\n      first,\n      last\n    }];\n  };\n  _updateViewableItems(props, cellsAroundViewport) {\n    if (this.state.pendingScrollUpdateCount > 0) {\n      return;\n    }\n    this._viewabilityTuples.forEach(tuple => {\n      tuple.viewabilityHelper.onUpdate(props, this._scrollMetrics.offset, this._scrollMetrics.visibleLength, this._getFrameMetrics, this._createViewToken, tuple.onViewableItemsChanged, cellsAroundViewport);\n    });\n  }\n}\nconst styles = StyleSheet.create({\n  verticallyInverted: Platform.OS === 'android' ? {\n    transform: [{\n      scale: -1\n    }]\n  } : {\n    transform: [{\n      scaleY: -1\n    }]\n  },\n  horizontallyInverted: {\n    transform: [{\n      scaleX: -1\n    }]\n  },\n  debug: {\n    flex: 1\n  },\n  debugOverlayBase: {\n    position: 'absolute',\n    top: 0,\n    right: 0\n  },\n  debugOverlay: {\n    bottom: 0,\n    width: 20,\n    borderColor: 'blue',\n    borderWidth: 1\n  },\n  debugOverlayFrame: {\n    left: 0,\n    backgroundColor: 'orange'\n  },\n  debugOverlayFrameLast: {\n    left: 0,\n    borderColor: 'green',\n    borderWidth: 2\n  },\n  debugOverlayFrameVis: {\n    left: 0,\n    borderColor: 'red',\n    borderWidth: 2\n  }\n});\nmodule.exports = VirtualizedList;","map":{"version":3,"names":["Batchinator","clamp","infoLog","CellRenderMask","ChildListCollection","FillRateHelper","StateSafePureComponent","ViewabilityHelper","CellRenderer","VirtualizedListCellContextProvider","VirtualizedListContext","VirtualizedListContextProvider","computeWindowedRenderLimits","keyExtractor","defaultKeyExtractor","invariant","nullthrows","React","jsxDEV","_jsxDEV","ON_EDGE_REACHED_EPSILON","_usedIndexForKey","_keylessItemComponentName","horizontalOrDefault","horizontal","initialNumToRenderOrDefault","initialNumToRender","maxToRenderPerBatchOrDefault","maxToRenderPerBatch","onStartReachedThresholdOrDefault","onStartReachedThreshold","onEndReachedThresholdOrDefault","onEndReachedThreshold","getScrollingThreshold","threshold","visibleLength","scrollEventThrottleOrDefault","scrollEventThrottle","windowSizeOrDefault","windowSize","findLastWhere","arr","predicate","i","length","VirtualizedList","contextType","scrollToEnd","params","animated","veryLast","props","getItemCount","data","frame","__getFrameMetricsApprox","offset","Math","max","_footerLength","_scrollMetrics","_scrollRef","scrollTo","console","warn","x","y","scrollToIndex","getItemLayout","onScrollToIndexFailed","index","viewOffset","viewPosition","_highestMeasuredFrameIndex","averageItemLength","_averageCellLength","highestMeasuredFrameIndex","floor","_getOffsetApprox","scrollToItem","item","getItem","itemCount","Object","assign","scrollToOffset","recordInteraction","_nestedChildLists","forEach","childList","_viewabilityTuples","t","viewabilityHelper","_updateViewableItems","state","cellsAroundViewport","flashScrollIndicators","getScrollResponder","getScrollableNode","findNodeHandle","getScrollRef","setNativeProps","_getCellKey","context","cellKey","_getScrollMetrics","hasMore","_hasMore","_getOutermostParentListRef","_isNestedWithSameOrientation","getOutermostParentListRef","_registerAsNestedChild","add","ref","_hasInteracted","_unregisterAsNestedChild","remove","constructor","_checkProps","_fillRateHelper","_getFrameMetrics","_updateCellsToRenderBatcher","_updateCellsToRender","updateCellsBatchingPeriod","viewabilityConfigCallbackPairs","map","pair","viewabilityConfig","onViewableItemsChanged","push","initialRenderRegion","_initialRenderRegion","minIndexForVisible","maintainVisibleContentPosition","renderMask","_createRenderMask","firstVisibleItemKey","_getItemKey","pendingScrollUpdateCount","initialScrollIndex","onScroll","__isNative","_hasTriggeredInitialScrollToIndex","_hasWarned","__DEV__","flexWrap","flatStyles","StyleSheet","flatten","contentContainerStyle","_findItemIndexWithKey","key","hint","curKey","ii","_keyExtractor","additionalRegions","first","last","allRegions","region","addCells","initialRegion","stickyIndicesSet","Set","stickyHeaderIndices","_ensureClosestStickyHeader","firstCellIndex","min","lastCellIndex","cellIdx","stickyOffset","ListHeaderComponent","itemIdx","has","_adjustCellsAroundViewport","contentLength","distanceFromEnd","_constrainToItemCount","newCellsAroundViewport","disableVirtualization","renderAhead","size","childIdx","_findFirstChildWithMore","cellKeyForIndex","_indicesToKeys","get","anyInCell","componentDidMount","registerAsNestedChild","componentWillUnmount","unregisterAsNestedChild","dispose","abort","tuple","deactivateAndFlush","getDerivedStateFromProps","newProps","prevState","numCells","maintainVisibleContentPositionAdjustment","prevFirstVisibleItemKey","newFirstVisibleItemKey","firstVisibleItemIndex","constrainedCells","_pushCells","cells","stickyIndicesFromProps","inversionStyle","CellRendererComponent","ItemSeparatorComponent","ListItemComponent","debug","renderItem","end","prevCellKey","set","shouldListenForLayout","enabled","undefined","onUpdateSeparators","_onUpdateSeparators","onCellFocusCapture","e","_onCellFocusCapture","onUnmount","_onCellUnmount","_cellRefs","onCellLayout","_onCellLayout","fileName","_jsxFileName","lineNumber","columnNumber","keys","updateSeparatorProps","nestedContext","_getSpacerKey","isVertical","String","type","displayName","render","ListEmptyComponent","ListFooterComponent","inverted","styles","horizontallyInverted","verticallyInverted","element","isValidElement","children","View","collapsable","onLayout","_onLayoutHeader","style","compose","ListHeaderComponentStyle","cloneElement","event","_onLayoutEmpty","spacerKey","renderRegions","enumerateRegions","lastSpacer","r","isSpacer","section","isLastSpacer","constrainToMeasured","firstMetrics","lastMetrics","spacerSize","_getFooterCellKey","_onLayoutFooter","ListFooterComponentStyle","scrollProps","onContentSizeChange","_onContentSizeChange","_onLayout","_onScroll","onScrollBeginDrag","_onScrollBeginDrag","onScrollEndDrag","_onScrollEndDrag","onMomentumScrollBegin","_onMomentumScrollBegin","onMomentumScrollEnd","_onMomentumScrollEnd","invertStickyHeaders","isInvertedVirtualizedList","innerRet","value","getScrollMetrics","renderScrollComponent","_defaultRenderScrollComponent","_captureScrollRef","ret","ScrollView","Context","Consumer","scrollContext","nesting","scrollEnabled","error","_renderDebugOverlay","componentDidUpdate","prevProps","extraData","resetViewableIndices","hiPriInProgress","_hiPriInProgress","_scheduleCellsToRenderUpdate","_frames","_headerLength","Map","_lastFocusedCellKey","_offsetFromParentVirtualizedList","_prevParentOffset","dOffset","dt","timestamp","velocity","zoomScale","_sentStartForContentLength","_sentEndForContentLength","_totalCellLength","_totalCellsMeasured","_computeBlankness","computeBlankness","onRefresh","refreshing","JSON","stringify","refreshControl","RefreshControl","progressViewOffset","layout","nativeEvent","next","_selectOffset","_selectLength","inLayout","curr","_triggerRemeasureForChildListsInCell","forEachInCell","measureLayoutRelativeToContainingList","measureLayout","width","height","scrollMetrics","_convertParentScrollMetrics","metricsChanged","stack","_maybeCallOnEdgeReached","normalize","framesInLayout","windowTop","frameLast","windowLen","visTop","visLen","debugOverlayBase","debugOverlay","f","debugOverlayFrame","top","debugOverlayFrameLast","debugOverlayFrameVis","metrics","onStartReached","onEndReached","distanceFromStart","DEFAULT_THRESHOLD_PX","startThreshold","endThreshold","isWithinStartThreshold","isWithinEndThreshold","contentOffset","timeStamp","layoutMeasurement","contentSize","perf","prevDt","setState","activate","hiPri","distTop","distBottom","schedule","_getNonViewportRenderRegions","equals","_createViewToken","isViewable","Number","isInteger","frameMetrics","remainder","lastFocusedCellRenderer","focusedCellIndex","heightOfCellsBeforeFocused","heightOfCellsAfterFocused","onUpdate","create","Platform","OS","transform","scale","scaleY","scaleX","flex","position","right","bottom","borderColor","borderWidth","left","backgroundColor","module","exports"],"sources":["C:/Users/Dhrumil/VS Code/projectdemo/src/node_modules/@react-native/virtualized-lists/Lists/VirtualizedList.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n * @format\n */\n\nimport type {ScrollResponderType} from 'react-native/Libraries/Components/ScrollView/ScrollView';\nimport type {ViewStyleProp} from 'react-native/Libraries/StyleSheet/StyleSheet';\nimport type {\n  LayoutEvent,\n  ScrollEvent,\n} from 'react-native/Libraries/Types/CoreEventTypes';\nimport type {ViewToken} from './ViewabilityHelper';\nimport type {\n  FrameMetricProps,\n  Item,\n  Props,\n  RenderItemProps,\n  RenderItemType,\n  Separators,\n} from './VirtualizedListProps';\n\nimport {\n  Platform,\n  RefreshControl,\n  ScrollView,\n  View,\n  StyleSheet,\n  findNodeHandle,\n} from 'react-native';\nimport Batchinator from '../Interaction/Batchinator';\nimport clamp from '../Utilities/clamp';\nimport infoLog from '../Utilities/infoLog';\nimport {CellRenderMask} from './CellRenderMask';\nimport ChildListCollection from './ChildListCollection';\nimport FillRateHelper from './FillRateHelper';\nimport StateSafePureComponent from './StateSafePureComponent';\nimport ViewabilityHelper from './ViewabilityHelper';\nimport CellRenderer from './VirtualizedListCellRenderer';\nimport {\n  VirtualizedListCellContextProvider,\n  VirtualizedListContext,\n  VirtualizedListContextProvider,\n} from './VirtualizedListContext.js';\nimport {\n  computeWindowedRenderLimits,\n  keyExtractor as defaultKeyExtractor,\n} from './VirtualizeUtils';\nimport invariant from 'invariant';\nimport nullthrows from 'nullthrows';\nimport * as React from 'react';\n\nexport type {RenderItemProps, RenderItemType, Separators};\n\nconst ON_EDGE_REACHED_EPSILON = 0.001;\n\nlet _usedIndexForKey = false;\nlet _keylessItemComponentName: string = '';\n\ntype ViewabilityHelperCallbackTuple = {\n  viewabilityHelper: ViewabilityHelper,\n  onViewableItemsChanged: (info: {\n    viewableItems: Array<ViewToken>,\n    changed: Array<ViewToken>,\n    ...\n  }) => void,\n  ...\n};\n\ntype State = {\n  renderMask: CellRenderMask,\n  cellsAroundViewport: {first: number, last: number},\n  // Used to track items added at the start of the list for maintainVisibleContentPosition.\n  firstVisibleItemKey: ?string,\n  // When > 0 the scroll position available in JS is considered stale and should not be used.\n  pendingScrollUpdateCount: number,\n};\n\n/**\n * Default Props Helper Functions\n * Use the following helper functions for default values\n */\n\n// horizontalOrDefault(this.props.horizontal)\nfunction horizontalOrDefault(horizontal: ?boolean) {\n  return horizontal ?? false;\n}\n\n// initialNumToRenderOrDefault(this.props.initialNumToRender)\nfunction initialNumToRenderOrDefault(initialNumToRender: ?number) {\n  return initialNumToRender ?? 10;\n}\n\n// maxToRenderPerBatchOrDefault(this.props.maxToRenderPerBatch)\nfunction maxToRenderPerBatchOrDefault(maxToRenderPerBatch: ?number) {\n  return maxToRenderPerBatch ?? 10;\n}\n\n// onStartReachedThresholdOrDefault(this.props.onStartReachedThreshold)\nfunction onStartReachedThresholdOrDefault(onStartReachedThreshold: ?number) {\n  return onStartReachedThreshold ?? 2;\n}\n\n// onEndReachedThresholdOrDefault(this.props.onEndReachedThreshold)\nfunction onEndReachedThresholdOrDefault(onEndReachedThreshold: ?number) {\n  return onEndReachedThreshold ?? 2;\n}\n\n// getScrollingThreshold(visibleLength, onEndReachedThreshold)\nfunction getScrollingThreshold(threshold: number, visibleLength: number) {\n  return (threshold * visibleLength) / 2;\n}\n\n// scrollEventThrottleOrDefault(this.props.scrollEventThrottle)\nfunction scrollEventThrottleOrDefault(scrollEventThrottle: ?number) {\n  return scrollEventThrottle ?? 50;\n}\n\n// windowSizeOrDefault(this.props.windowSize)\nfunction windowSizeOrDefault(windowSize: ?number) {\n  return windowSize ?? 21;\n}\n\nfunction findLastWhere<T>(\n  arr: $ReadOnlyArray<T>,\n  predicate: (element: T) => boolean,\n): T | null {\n  for (let i = arr.length - 1; i >= 0; i--) {\n    if (predicate(arr[i])) {\n      return arr[i];\n    }\n  }\n\n  return null;\n}\n\n/**\n * Base implementation for the more convenient [`<FlatList>`](https://reactnative.dev/docs/flatlist)\n * and [`<SectionList>`](https://reactnative.dev/docs/sectionlist) components, which are also better\n * documented. In general, this should only really be used if you need more flexibility than\n * `FlatList` provides, e.g. for use with immutable data instead of plain arrays.\n *\n * Virtualization massively improves memory consumption and performance of large lists by\n * maintaining a finite render window of active items and replacing all items outside of the render\n * window with appropriately sized blank space. The window adapts to scrolling behavior, and items\n * are rendered incrementally with low-pri (after any running interactions) if they are far from the\n * visible area, or with hi-pri otherwise to minimize the potential of seeing blank space.\n *\n * Some caveats:\n *\n * - Internal state is not preserved when content scrolls out of the render window. Make sure all\n *   your data is captured in the item data or external stores like Flux, Redux, or Relay.\n * - This is a `PureComponent` which means that it will not re-render if `props` remain shallow-\n *   equal. Make sure that everything your `renderItem` function depends on is passed as a prop\n *   (e.g. `extraData`) that is not `===` after updates, otherwise your UI may not update on\n *   changes. This includes the `data` prop and parent component state.\n * - In order to constrain memory and enable smooth scrolling, content is rendered asynchronously\n *   offscreen. This means it's possible to scroll faster than the fill rate ands momentarily see\n *   blank content. This is a tradeoff that can be adjusted to suit the needs of each application,\n *   and we are working on improving it behind the scenes.\n * - By default, the list looks for a `key` or `id` prop on each item and uses that for the React key.\n *   Alternatively, you can provide a custom `keyExtractor` prop.\n * - As an effort to remove defaultProps, use helper functions when referencing certain props\n *\n */\nclass VirtualizedList extends StateSafePureComponent<Props, State> {\n  static contextType: typeof VirtualizedListContext = VirtualizedListContext;\n\n  // scrollToEnd may be janky without getItemLayout prop\n  scrollToEnd(params?: ?{animated?: ?boolean, ...}) {\n    const animated = params ? params.animated : true;\n    const veryLast = this.props.getItemCount(this.props.data) - 1;\n    if (veryLast < 0) {\n      return;\n    }\n    const frame = this.__getFrameMetricsApprox(veryLast, this.props);\n    const offset = Math.max(\n      0,\n      frame.offset +\n        frame.length +\n        this._footerLength -\n        this._scrollMetrics.visibleLength,\n    );\n\n    if (this._scrollRef == null) {\n      return;\n    }\n\n    if (this._scrollRef.scrollTo == null) {\n      console.warn(\n        'No scrollTo method provided. This may be because you have two nested ' +\n          'VirtualizedLists with the same orientation, or because you are ' +\n          'using a custom component that does not implement scrollTo.',\n      );\n      return;\n    }\n\n    this._scrollRef.scrollTo(\n      horizontalOrDefault(this.props.horizontal)\n        ? {x: offset, animated}\n        : {y: offset, animated},\n    );\n  }\n\n  // scrollToIndex may be janky without getItemLayout prop\n  scrollToIndex(params: {\n    animated?: ?boolean,\n    index: number,\n    viewOffset?: number,\n    viewPosition?: number,\n    ...\n  }): $FlowFixMe {\n    const {\n      data,\n      horizontal,\n      getItemCount,\n      getItemLayout,\n      onScrollToIndexFailed,\n    } = this.props;\n    const {animated, index, viewOffset, viewPosition} = params;\n    invariant(\n      index >= 0,\n      `scrollToIndex out of range: requested index ${index} but minimum is 0`,\n    );\n    invariant(\n      getItemCount(data) >= 1,\n      `scrollToIndex out of range: item length ${getItemCount(\n        data,\n      )} but minimum is 1`,\n    );\n    invariant(\n      index < getItemCount(data),\n      `scrollToIndex out of range: requested index ${index} is out of 0 to ${\n        getItemCount(data) - 1\n      }`,\n    );\n    if (!getItemLayout && index > this._highestMeasuredFrameIndex) {\n      invariant(\n        !!onScrollToIndexFailed,\n        'scrollToIndex should be used in conjunction with getItemLayout or onScrollToIndexFailed, ' +\n          'otherwise there is no way to know the location of offscreen indices or handle failures.',\n      );\n      onScrollToIndexFailed({\n        averageItemLength: this._averageCellLength,\n        highestMeasuredFrameIndex: this._highestMeasuredFrameIndex,\n        index,\n      });\n      return;\n    }\n    const frame = this.__getFrameMetricsApprox(Math.floor(index), this.props);\n    const offset =\n      Math.max(\n        0,\n        this._getOffsetApprox(index, this.props) -\n          (viewPosition || 0) *\n            (this._scrollMetrics.visibleLength - frame.length),\n      ) - (viewOffset || 0);\n\n    if (this._scrollRef == null) {\n      return;\n    }\n\n    if (this._scrollRef.scrollTo == null) {\n      console.warn(\n        'No scrollTo method provided. This may be because you have two nested ' +\n          'VirtualizedLists with the same orientation, or because you are ' +\n          'using a custom component that does not implement scrollTo.',\n      );\n      return;\n    }\n\n    this._scrollRef.scrollTo(\n      horizontal ? {x: offset, animated} : {y: offset, animated},\n    );\n  }\n\n  // scrollToItem may be janky without getItemLayout prop. Required linear scan through items -\n  // use scrollToIndex instead if possible.\n  scrollToItem(params: {\n    animated?: ?boolean,\n    item: Item,\n    viewOffset?: number,\n    viewPosition?: number,\n    ...\n  }) {\n    const {item} = params;\n    const {data, getItem, getItemCount} = this.props;\n    const itemCount = getItemCount(data);\n    for (let index = 0; index < itemCount; index++) {\n      if (getItem(data, index) === item) {\n        this.scrollToIndex({...params, index});\n        break;\n      }\n    }\n  }\n\n  /**\n   * Scroll to a specific content pixel offset in the list.\n   *\n   * Param `offset` expects the offset to scroll to.\n   * In case of `horizontal` is true, the offset is the x-value,\n   * in any other case the offset is the y-value.\n   *\n   * Param `animated` (`true` by default) defines whether the list\n   * should do an animation while scrolling.\n   */\n  scrollToOffset(params: {animated?: ?boolean, offset: number, ...}) {\n    const {animated, offset} = params;\n\n    if (this._scrollRef == null) {\n      return;\n    }\n\n    if (this._scrollRef.scrollTo == null) {\n      console.warn(\n        'No scrollTo method provided. This may be because you have two nested ' +\n          'VirtualizedLists with the same orientation, or because you are ' +\n          'using a custom component that does not implement scrollTo.',\n      );\n      return;\n    }\n\n    this._scrollRef.scrollTo(\n      horizontalOrDefault(this.props.horizontal)\n        ? {x: offset, animated}\n        : {y: offset, animated},\n    );\n  }\n\n  recordInteraction() {\n    this._nestedChildLists.forEach(childList => {\n      childList.recordInteraction();\n    });\n    this._viewabilityTuples.forEach(t => {\n      t.viewabilityHelper.recordInteraction();\n    });\n    this._updateViewableItems(this.props, this.state.cellsAroundViewport);\n  }\n\n  flashScrollIndicators() {\n    if (this._scrollRef == null) {\n      return;\n    }\n\n    this._scrollRef.flashScrollIndicators();\n  }\n\n  /**\n   * Provides a handle to the underlying scroll responder.\n   * Note that `this._scrollRef` might not be a `ScrollView`, so we\n   * need to check that it responds to `getScrollResponder` before calling it.\n   */\n  getScrollResponder(): ?ScrollResponderType {\n    if (this._scrollRef && this._scrollRef.getScrollResponder) {\n      return this._scrollRef.getScrollResponder();\n    }\n  }\n\n  getScrollableNode(): ?number {\n    if (this._scrollRef && this._scrollRef.getScrollableNode) {\n      return this._scrollRef.getScrollableNode();\n    } else {\n      return findNodeHandle(this._scrollRef);\n    }\n  }\n\n  getScrollRef():\n    | ?React.ElementRef<typeof ScrollView>\n    | ?React.ElementRef<typeof View> {\n    if (this._scrollRef && this._scrollRef.getScrollRef) {\n      return this._scrollRef.getScrollRef();\n    } else {\n      return this._scrollRef;\n    }\n  }\n\n  setNativeProps(props: Object) {\n    if (this._scrollRef) {\n      this._scrollRef.setNativeProps(props);\n    }\n  }\n\n  _getCellKey(): string {\n    return this.context?.cellKey || 'rootList';\n  }\n\n  // $FlowFixMe[missing-local-annot]\n  _getScrollMetrics = () => {\n    return this._scrollMetrics;\n  };\n\n  hasMore(): boolean {\n    return this._hasMore;\n  }\n\n  // $FlowFixMe[missing-local-annot]\n  _getOutermostParentListRef = () => {\n    if (this._isNestedWithSameOrientation()) {\n      return this.context.getOutermostParentListRef();\n    } else {\n      return this;\n    }\n  };\n\n  _registerAsNestedChild = (childList: {\n    cellKey: string,\n    ref: React.ElementRef<typeof VirtualizedList>,\n  }): void => {\n    this._nestedChildLists.add(childList.ref, childList.cellKey);\n    if (this._hasInteracted) {\n      childList.ref.recordInteraction();\n    }\n  };\n\n  _unregisterAsNestedChild = (childList: {\n    ref: React.ElementRef<typeof VirtualizedList>,\n  }): void => {\n    this._nestedChildLists.remove(childList.ref);\n  };\n\n  state: State;\n\n  constructor(props: Props) {\n    super(props);\n    this._checkProps(props);\n\n    this._fillRateHelper = new FillRateHelper(this._getFrameMetrics);\n    this._updateCellsToRenderBatcher = new Batchinator(\n      this._updateCellsToRender,\n      this.props.updateCellsBatchingPeriod ?? 50,\n    );\n\n    if (this.props.viewabilityConfigCallbackPairs) {\n      this._viewabilityTuples = this.props.viewabilityConfigCallbackPairs.map(\n        pair => ({\n          viewabilityHelper: new ViewabilityHelper(pair.viewabilityConfig),\n          onViewableItemsChanged: pair.onViewableItemsChanged,\n        }),\n      );\n    } else {\n      const {onViewableItemsChanged, viewabilityConfig} = this.props;\n      if (onViewableItemsChanged) {\n        this._viewabilityTuples.push({\n          viewabilityHelper: new ViewabilityHelper(viewabilityConfig),\n          onViewableItemsChanged: onViewableItemsChanged,\n        });\n      }\n    }\n\n    const initialRenderRegion = VirtualizedList._initialRenderRegion(props);\n\n    const minIndexForVisible =\n      this.props.maintainVisibleContentPosition?.minIndexForVisible ?? 0;\n\n    this.state = {\n      cellsAroundViewport: initialRenderRegion,\n      renderMask: VirtualizedList._createRenderMask(props, initialRenderRegion),\n      firstVisibleItemKey:\n        this.props.getItemCount(this.props.data) > minIndexForVisible\n          ? VirtualizedList._getItemKey(this.props, minIndexForVisible)\n          : null,\n      // When we have a non-zero initialScrollIndex, we will receive a\n      // scroll event later so this will prevent the window from updating\n      // until we get a valid offset.\n      pendingScrollUpdateCount:\n        this.props.initialScrollIndex != null &&\n        this.props.initialScrollIndex > 0\n          ? 1\n          : 0,\n    };\n  }\n\n  _checkProps(props: Props) {\n    const {onScroll, windowSize, getItemCount, data, initialScrollIndex} =\n      props;\n\n    invariant(\n      // $FlowFixMe[prop-missing]\n      !onScroll || !onScroll.__isNative,\n      'Components based on VirtualizedList must be wrapped with Animated.createAnimatedComponent ' +\n        'to support native onScroll events with useNativeDriver',\n    );\n    invariant(\n      windowSizeOrDefault(windowSize) > 0,\n      'VirtualizedList: The windowSize prop must be present and set to a value greater than 0.',\n    );\n\n    invariant(\n      getItemCount,\n      'VirtualizedList: The \"getItemCount\" prop must be provided',\n    );\n\n    const itemCount = getItemCount(data);\n\n    if (\n      initialScrollIndex != null &&\n      !this._hasTriggeredInitialScrollToIndex &&\n      (initialScrollIndex < 0 ||\n        (itemCount > 0 && initialScrollIndex >= itemCount)) &&\n      !this._hasWarned.initialScrollIndex\n    ) {\n      console.warn(\n        `initialScrollIndex \"${initialScrollIndex}\" is not valid (list has ${itemCount} items)`,\n      );\n      this._hasWarned.initialScrollIndex = true;\n    }\n\n    if (__DEV__ && !this._hasWarned.flexWrap) {\n      // $FlowFixMe[underconstrained-implicit-instantiation]\n      const flatStyles = StyleSheet.flatten(this.props.contentContainerStyle);\n      if (flatStyles != null && flatStyles.flexWrap === 'wrap') {\n        console.warn(\n          '`flexWrap: `wrap`` is not supported with the `VirtualizedList` components.' +\n            'Consider using `numColumns` with `FlatList` instead.',\n        );\n        this._hasWarned.flexWrap = true;\n      }\n    }\n  }\n\n  static _findItemIndexWithKey(\n    props: Props,\n    key: string,\n    hint: ?number,\n  ): ?number {\n    const itemCount = props.getItemCount(props.data);\n    if (hint != null && hint >= 0 && hint < itemCount) {\n      const curKey = VirtualizedList._getItemKey(props, hint);\n      if (curKey === key) {\n        return hint;\n      }\n    }\n    for (let ii = 0; ii < itemCount; ii++) {\n      const curKey = VirtualizedList._getItemKey(props, ii);\n      if (curKey === key) {\n        return ii;\n      }\n    }\n    return null;\n  }\n\n  static _getItemKey(\n    props: {\n      data: Props['data'],\n      getItem: Props['getItem'],\n      keyExtractor: Props['keyExtractor'],\n      ...\n    },\n    index: number,\n  ): string {\n    const item = props.getItem(props.data, index);\n    return VirtualizedList._keyExtractor(item, index, props);\n  }\n\n  static _createRenderMask(\n    props: Props,\n    cellsAroundViewport: {first: number, last: number},\n    additionalRegions?: ?$ReadOnlyArray<{first: number, last: number}>,\n  ): CellRenderMask {\n    const itemCount = props.getItemCount(props.data);\n\n    invariant(\n      cellsAroundViewport.first >= 0 &&\n        cellsAroundViewport.last >= cellsAroundViewport.first - 1 &&\n        cellsAroundViewport.last < itemCount,\n      `Invalid cells around viewport \"[${cellsAroundViewport.first}, ${cellsAroundViewport.last}]\" was passed to VirtualizedList._createRenderMask`,\n    );\n\n    const renderMask = new CellRenderMask(itemCount);\n\n    if (itemCount > 0) {\n      const allRegions = [cellsAroundViewport, ...(additionalRegions ?? [])];\n      for (const region of allRegions) {\n        renderMask.addCells(region);\n      }\n\n      // The initially rendered cells are retained as part of the\n      // \"scroll-to-top\" optimization\n      if (props.initialScrollIndex == null || props.initialScrollIndex <= 0) {\n        const initialRegion = VirtualizedList._initialRenderRegion(props);\n        renderMask.addCells(initialRegion);\n      }\n\n      // The layout coordinates of sticker headers may be off-screen while the\n      // actual header is on-screen. Keep the most recent before the viewport\n      // rendered, even if its layout coordinates are not in viewport.\n      const stickyIndicesSet = new Set(props.stickyHeaderIndices);\n      VirtualizedList._ensureClosestStickyHeader(\n        props,\n        stickyIndicesSet,\n        renderMask,\n        cellsAroundViewport.first,\n      );\n    }\n\n    return renderMask;\n  }\n\n  static _initialRenderRegion(props: Props): {first: number, last: number} {\n    const itemCount = props.getItemCount(props.data);\n\n    const firstCellIndex = Math.max(\n      0,\n      Math.min(itemCount - 1, Math.floor(props.initialScrollIndex ?? 0)),\n    );\n\n    const lastCellIndex =\n      Math.min(\n        itemCount,\n        firstCellIndex + initialNumToRenderOrDefault(props.initialNumToRender),\n      ) - 1;\n\n    return {\n      first: firstCellIndex,\n      last: lastCellIndex,\n    };\n  }\n\n  static _ensureClosestStickyHeader(\n    props: Props,\n    stickyIndicesSet: Set<number>,\n    renderMask: CellRenderMask,\n    cellIdx: number,\n  ) {\n    const stickyOffset = props.ListHeaderComponent ? 1 : 0;\n\n    for (let itemIdx = cellIdx - 1; itemIdx >= 0; itemIdx--) {\n      if (stickyIndicesSet.has(itemIdx + stickyOffset)) {\n        renderMask.addCells({first: itemIdx, last: itemIdx});\n        break;\n      }\n    }\n  }\n\n  _adjustCellsAroundViewport(\n    props: Props,\n    cellsAroundViewport: {first: number, last: number},\n    pendingScrollUpdateCount: number,\n  ): {first: number, last: number} {\n    const {data, getItemCount} = props;\n    const onEndReachedThreshold = onEndReachedThresholdOrDefault(\n      props.onEndReachedThreshold,\n    );\n    const {contentLength, offset, visibleLength} = this._scrollMetrics;\n    const distanceFromEnd = contentLength - visibleLength - offset;\n\n    // Wait until the scroll view metrics have been set up. And until then,\n    // we will trust the initialNumToRender suggestion\n    if (visibleLength <= 0 || contentLength <= 0) {\n      return cellsAroundViewport.last >= getItemCount(data)\n        ? VirtualizedList._constrainToItemCount(cellsAroundViewport, props)\n        : cellsAroundViewport;\n    }\n\n    let newCellsAroundViewport: {first: number, last: number};\n    if (props.disableVirtualization) {\n      const renderAhead =\n        distanceFromEnd < onEndReachedThreshold * visibleLength\n          ? maxToRenderPerBatchOrDefault(props.maxToRenderPerBatch)\n          : 0;\n\n      newCellsAroundViewport = {\n        first: 0,\n        last: Math.min(\n          cellsAroundViewport.last + renderAhead,\n          getItemCount(data) - 1,\n        ),\n      };\n    } else {\n      // If we have a pending scroll update, we should not adjust the render window as it\n      // might override the correct window.\n      if (pendingScrollUpdateCount > 0) {\n        return cellsAroundViewport.last >= getItemCount(data)\n          ? VirtualizedList._constrainToItemCount(cellsAroundViewport, props)\n          : cellsAroundViewport;\n      }\n\n      newCellsAroundViewport = computeWindowedRenderLimits(\n        props,\n        maxToRenderPerBatchOrDefault(props.maxToRenderPerBatch),\n        windowSizeOrDefault(props.windowSize),\n        cellsAroundViewport,\n        this.__getFrameMetricsApprox,\n        this._scrollMetrics,\n      );\n      invariant(\n        newCellsAroundViewport.last < getItemCount(data),\n        'computeWindowedRenderLimits() should return range in-bounds',\n      );\n    }\n\n    if (this._nestedChildLists.size() > 0) {\n      // If some cell in the new state has a child list in it, we should only render\n      // up through that item, so that we give that list a chance to render.\n      // Otherwise there's churn from multiple child lists mounting and un-mounting\n      // their items.\n\n      // Will this prevent rendering if the nested list doesn't realize the end?\n      const childIdx = this._findFirstChildWithMore(\n        newCellsAroundViewport.first,\n        newCellsAroundViewport.last,\n      );\n\n      newCellsAroundViewport.last = childIdx ?? newCellsAroundViewport.last;\n    }\n\n    return newCellsAroundViewport;\n  }\n\n  _findFirstChildWithMore(first: number, last: number): number | null {\n    for (let ii = first; ii <= last; ii++) {\n      const cellKeyForIndex = this._indicesToKeys.get(ii);\n      if (\n        cellKeyForIndex != null &&\n        this._nestedChildLists.anyInCell(cellKeyForIndex, childList =>\n          childList.hasMore(),\n        )\n      ) {\n        return ii;\n      }\n    }\n\n    return null;\n  }\n\n  componentDidMount() {\n    if (this._isNestedWithSameOrientation()) {\n      this.context.registerAsNestedChild({\n        ref: this,\n        cellKey: this.context.cellKey,\n      });\n    }\n  }\n\n  componentWillUnmount() {\n    if (this._isNestedWithSameOrientation()) {\n      this.context.unregisterAsNestedChild({ref: this});\n    }\n    this._updateCellsToRenderBatcher.dispose({abort: true});\n    this._viewabilityTuples.forEach(tuple => {\n      tuple.viewabilityHelper.dispose();\n    });\n    this._fillRateHelper.deactivateAndFlush();\n  }\n\n  static getDerivedStateFromProps(newProps: Props, prevState: State): State {\n    // first and last could be stale (e.g. if a new, shorter items props is passed in), so we make\n    // sure we're rendering a reasonable range here.\n    const itemCount = newProps.getItemCount(newProps.data);\n    if (itemCount === prevState.renderMask.numCells()) {\n      return prevState;\n    }\n\n    let maintainVisibleContentPositionAdjustment: ?number = null;\n    const prevFirstVisibleItemKey = prevState.firstVisibleItemKey;\n    const minIndexForVisible =\n      newProps.maintainVisibleContentPosition?.minIndexForVisible ?? 0;\n    const newFirstVisibleItemKey =\n      newProps.getItemCount(newProps.data) > minIndexForVisible\n        ? VirtualizedList._getItemKey(newProps, minIndexForVisible)\n        : null;\n    if (\n      newProps.maintainVisibleContentPosition != null &&\n      prevFirstVisibleItemKey != null &&\n      newFirstVisibleItemKey != null\n    ) {\n      if (newFirstVisibleItemKey !== prevFirstVisibleItemKey) {\n        // Fast path if items were added at the start of the list.\n        const hint =\n          itemCount - prevState.renderMask.numCells() + minIndexForVisible;\n        const firstVisibleItemIndex = VirtualizedList._findItemIndexWithKey(\n          newProps,\n          prevFirstVisibleItemKey,\n          hint,\n        );\n        maintainVisibleContentPositionAdjustment =\n          firstVisibleItemIndex != null\n            ? firstVisibleItemIndex - minIndexForVisible\n            : null;\n      } else {\n        maintainVisibleContentPositionAdjustment = null;\n      }\n    }\n\n    const constrainedCells = VirtualizedList._constrainToItemCount(\n      maintainVisibleContentPositionAdjustment != null\n        ? {\n            first:\n              prevState.cellsAroundViewport.first +\n              maintainVisibleContentPositionAdjustment,\n            last:\n              prevState.cellsAroundViewport.last +\n              maintainVisibleContentPositionAdjustment,\n          }\n        : prevState.cellsAroundViewport,\n      newProps,\n    );\n\n    return {\n      cellsAroundViewport: constrainedCells,\n      renderMask: VirtualizedList._createRenderMask(newProps, constrainedCells),\n      firstVisibleItemKey: newFirstVisibleItemKey,\n      pendingScrollUpdateCount:\n        maintainVisibleContentPositionAdjustment != null\n          ? prevState.pendingScrollUpdateCount + 1\n          : prevState.pendingScrollUpdateCount,\n    };\n  }\n\n  _pushCells(\n    cells: Array<Object>,\n    stickyHeaderIndices: Array<number>,\n    stickyIndicesFromProps: Set<number>,\n    first: number,\n    last: number,\n    inversionStyle: ViewStyleProp,\n  ) {\n    const {\n      CellRendererComponent,\n      ItemSeparatorComponent,\n      ListHeaderComponent,\n      ListItemComponent,\n      data,\n      debug,\n      getItem,\n      getItemCount,\n      getItemLayout,\n      horizontal,\n      renderItem,\n    } = this.props;\n    const stickyOffset = ListHeaderComponent ? 1 : 0;\n    const end = getItemCount(data) - 1;\n    let prevCellKey;\n    last = Math.min(end, last);\n\n    for (let ii = first; ii <= last; ii++) {\n      const item = getItem(data, ii);\n      const key = VirtualizedList._keyExtractor(item, ii, this.props);\n\n      this._indicesToKeys.set(ii, key);\n      if (stickyIndicesFromProps.has(ii + stickyOffset)) {\n        stickyHeaderIndices.push(cells.length);\n      }\n\n      const shouldListenForLayout =\n        getItemLayout == null || debug || this._fillRateHelper.enabled();\n\n      cells.push(\n        <CellRenderer\n          CellRendererComponent={CellRendererComponent}\n          ItemSeparatorComponent={ii < end ? ItemSeparatorComponent : undefined}\n          ListItemComponent={ListItemComponent}\n          cellKey={key}\n          horizontal={horizontal}\n          index={ii}\n          inversionStyle={inversionStyle}\n          item={item}\n          key={key}\n          prevCellKey={prevCellKey}\n          onUpdateSeparators={this._onUpdateSeparators}\n          onCellFocusCapture={e => this._onCellFocusCapture(key)}\n          onUnmount={this._onCellUnmount}\n          ref={ref => {\n            this._cellRefs[key] = ref;\n          }}\n          renderItem={renderItem}\n          {...(shouldListenForLayout && {\n            onCellLayout: this._onCellLayout,\n          })}\n        />,\n      );\n      prevCellKey = key;\n    }\n  }\n\n  static _constrainToItemCount(\n    cells: {first: number, last: number},\n    props: Props,\n  ): {first: number, last: number} {\n    const itemCount = props.getItemCount(props.data);\n    const last = Math.min(itemCount - 1, cells.last);\n\n    const maxToRenderPerBatch = maxToRenderPerBatchOrDefault(\n      props.maxToRenderPerBatch,\n    );\n\n    return {\n      first: clamp(0, itemCount - 1 - maxToRenderPerBatch, cells.first),\n      last,\n    };\n  }\n\n  _onUpdateSeparators = (keys: Array<?string>, newProps: Object) => {\n    keys.forEach(key => {\n      const ref = key != null && this._cellRefs[key];\n      ref && ref.updateSeparatorProps(newProps);\n    });\n  };\n\n  _isNestedWithSameOrientation(): boolean {\n    const nestedContext = this.context;\n    return !!(\n      nestedContext &&\n      !!nestedContext.horizontal === horizontalOrDefault(this.props.horizontal)\n    );\n  }\n\n  _getSpacerKey = (isVertical: boolean): string =>\n    isVertical ? 'height' : 'width';\n\n  static _keyExtractor(\n    item: Item,\n    index: number,\n    props: {\n      keyExtractor?: ?(item: Item, index: number) => string,\n      ...\n    },\n  ): string {\n    if (props.keyExtractor != null) {\n      return props.keyExtractor(item, index);\n    }\n\n    const key = defaultKeyExtractor(item, index);\n    if (key === String(index)) {\n      _usedIndexForKey = true;\n      if (item.type && item.type.displayName) {\n        _keylessItemComponentName = item.type.displayName;\n      }\n    }\n    return key;\n  }\n\n  render(): React.Node {\n    this._checkProps(this.props);\n    const {ListEmptyComponent, ListFooterComponent, ListHeaderComponent} =\n      this.props;\n    const {data, horizontal} = this.props;\n    const inversionStyle = this.props.inverted\n      ? horizontalOrDefault(this.props.horizontal)\n        ? styles.horizontallyInverted\n        : styles.verticallyInverted\n      : null;\n    const cells: Array<any | React.Node> = [];\n    const stickyIndicesFromProps = new Set(this.props.stickyHeaderIndices);\n    const stickyHeaderIndices = [];\n\n    // 1. Add cell for ListHeaderComponent\n    if (ListHeaderComponent) {\n      if (stickyIndicesFromProps.has(0)) {\n        stickyHeaderIndices.push(0);\n      }\n      const element = React.isValidElement(ListHeaderComponent) ? (\n        ListHeaderComponent\n      ) : (\n        // $FlowFixMe[not-a-component]\n        // $FlowFixMe[incompatible-type-arg]\n        <ListHeaderComponent />\n      );\n      cells.push(\n        <VirtualizedListCellContextProvider\n          cellKey={this._getCellKey() + '-header'}\n          key=\"$header\">\n          <View\n            // We expect that header component will be a single native view so make it\n            // not collapsable to avoid this view being flattened and make this assumption\n            // no longer true.\n            collapsable={false}\n            onLayout={this._onLayoutHeader}\n            style={StyleSheet.compose(\n              inversionStyle,\n              this.props.ListHeaderComponentStyle,\n            )}>\n            {\n              // $FlowFixMe[incompatible-type] - Typing ReactNativeComponent revealed errors\n              element\n            }\n          </View>\n        </VirtualizedListCellContextProvider>,\n      );\n    }\n\n    // 2a. Add a cell for ListEmptyComponent if applicable\n    const itemCount = this.props.getItemCount(data);\n    if (itemCount === 0 && ListEmptyComponent) {\n      const element: React.Element<any> = ((React.isValidElement(\n        ListEmptyComponent,\n      ) ? (\n        ListEmptyComponent\n      ) : (\n        // $FlowFixMe[not-a-component]\n        // $FlowFixMe[incompatible-type-arg]\n        <ListEmptyComponent />\n      )): any);\n      cells.push(\n        <VirtualizedListCellContextProvider\n          cellKey={this._getCellKey() + '-empty'}\n          key=\"$empty\">\n          {React.cloneElement(element, {\n            onLayout: (event: LayoutEvent) => {\n              this._onLayoutEmpty(event);\n              if (element.props.onLayout) {\n                element.props.onLayout(event);\n              }\n            },\n            style: StyleSheet.compose(inversionStyle, element.props.style),\n          })}\n        </VirtualizedListCellContextProvider>,\n      );\n    }\n\n    // 2b. Add cells and spacers for each item\n    if (itemCount > 0) {\n      _usedIndexForKey = false;\n      _keylessItemComponentName = '';\n      const spacerKey = this._getSpacerKey(!horizontal);\n\n      const renderRegions = this.state.renderMask.enumerateRegions();\n      const lastSpacer = findLastWhere(renderRegions, r => r.isSpacer);\n\n      for (const section of renderRegions) {\n        if (section.isSpacer) {\n          // Legacy behavior is to avoid spacers when virtualization is\n          // disabled (including head spacers on initial render).\n          if (this.props.disableVirtualization) {\n            continue;\n          }\n\n          // Without getItemLayout, we limit our tail spacer to the _highestMeasuredFrameIndex to\n          // prevent the user for hyperscrolling into un-measured area because otherwise content will\n          // likely jump around as it renders in above the viewport.\n          const isLastSpacer = section === lastSpacer;\n          const constrainToMeasured = isLastSpacer && !this.props.getItemLayout;\n          const last = constrainToMeasured\n            ? clamp(\n                section.first - 1,\n                section.last,\n                this._highestMeasuredFrameIndex,\n              )\n            : section.last;\n\n          const firstMetrics = this.__getFrameMetricsApprox(\n            section.first,\n            this.props,\n          );\n          const lastMetrics = this.__getFrameMetricsApprox(last, this.props);\n          const spacerSize =\n            lastMetrics.offset + lastMetrics.length - firstMetrics.offset;\n          cells.push(\n            <View\n              key={`$spacer-${section.first}`}\n              style={{[spacerKey]: spacerSize}}\n            />,\n          );\n        } else {\n          this._pushCells(\n            cells,\n            stickyHeaderIndices,\n            stickyIndicesFromProps,\n            section.first,\n            section.last,\n            inversionStyle,\n          );\n        }\n      }\n\n      if (!this._hasWarned.keys && _usedIndexForKey) {\n        console.warn(\n          'VirtualizedList: missing keys for items, make sure to specify a key or id property on each ' +\n            'item or provide a custom keyExtractor.',\n          _keylessItemComponentName,\n        );\n        this._hasWarned.keys = true;\n      }\n    }\n\n    // 3. Add cell for ListFooterComponent\n    if (ListFooterComponent) {\n      const element = React.isValidElement(ListFooterComponent) ? (\n        ListFooterComponent\n      ) : (\n        // $FlowFixMe[not-a-component]\n        // $FlowFixMe[incompatible-type-arg]\n        <ListFooterComponent />\n      );\n      cells.push(\n        <VirtualizedListCellContextProvider\n          cellKey={this._getFooterCellKey()}\n          key=\"$footer\">\n          <View\n            onLayout={this._onLayoutFooter}\n            style={StyleSheet.compose(\n              inversionStyle,\n              this.props.ListFooterComponentStyle,\n            )}>\n            {\n              // $FlowFixMe[incompatible-type] - Typing ReactNativeComponent revealed errors\n              element\n            }\n          </View>\n        </VirtualizedListCellContextProvider>,\n      );\n    }\n\n    // 4. Render the ScrollView\n    const scrollProps = {\n      ...this.props,\n      onContentSizeChange: this._onContentSizeChange,\n      onLayout: this._onLayout,\n      onScroll: this._onScroll,\n      onScrollBeginDrag: this._onScrollBeginDrag,\n      onScrollEndDrag: this._onScrollEndDrag,\n      onMomentumScrollBegin: this._onMomentumScrollBegin,\n      onMomentumScrollEnd: this._onMomentumScrollEnd,\n      scrollEventThrottle: scrollEventThrottleOrDefault(\n        this.props.scrollEventThrottle,\n      ), // TODO: Android support\n      invertStickyHeaders:\n        this.props.invertStickyHeaders !== undefined\n          ? this.props.invertStickyHeaders\n          : this.props.inverted,\n      stickyHeaderIndices,\n      style: inversionStyle\n        ? [inversionStyle, this.props.style]\n        : this.props.style,\n      isInvertedVirtualizedList: this.props.inverted,\n      maintainVisibleContentPosition:\n        this.props.maintainVisibleContentPosition != null\n          ? {\n              ...this.props.maintainVisibleContentPosition,\n              // Adjust index to account for ListHeaderComponent.\n              minIndexForVisible:\n                this.props.maintainVisibleContentPosition.minIndexForVisible +\n                (this.props.ListHeaderComponent ? 1 : 0),\n            }\n          : undefined,\n    };\n\n    this._hasMore = this.state.cellsAroundViewport.last < itemCount - 1;\n\n    const innerRet = (\n      <VirtualizedListContextProvider\n        value={{\n          cellKey: null,\n          getScrollMetrics: this._getScrollMetrics,\n          horizontal: horizontalOrDefault(this.props.horizontal),\n          getOutermostParentListRef: this._getOutermostParentListRef,\n          registerAsNestedChild: this._registerAsNestedChild,\n          unregisterAsNestedChild: this._unregisterAsNestedChild,\n        }}>\n        {React.cloneElement(\n          (\n            this.props.renderScrollComponent ||\n            this._defaultRenderScrollComponent\n          )(scrollProps),\n          {\n            ref: this._captureScrollRef,\n          },\n          cells,\n        )}\n      </VirtualizedListContextProvider>\n    );\n    let ret: React.Node = innerRet;\n    if (__DEV__) {\n      ret = (\n        <ScrollView.Context.Consumer>\n          {scrollContext => {\n            if (\n              scrollContext != null &&\n              !scrollContext.horizontal ===\n                !horizontalOrDefault(this.props.horizontal) &&\n              !this._hasWarned.nesting &&\n              this.context == null &&\n              this.props.scrollEnabled !== false\n            ) {\n              // TODO (T46547044): use React.warn once 16.9 is sync'd: https://github.com/facebook/react/pull/15170\n              console.error(\n                'VirtualizedLists should never be nested inside plain ScrollViews with the same ' +\n                  'orientation because it can break windowing and other functionality - use another ' +\n                  'VirtualizedList-backed container instead.',\n              );\n              this._hasWarned.nesting = true;\n            }\n            return innerRet;\n          }}\n        </ScrollView.Context.Consumer>\n      );\n    }\n    if (this.props.debug) {\n      return (\n        <View style={styles.debug}>\n          {ret}\n          {this._renderDebugOverlay()}\n        </View>\n      );\n    } else {\n      return ret;\n    }\n  }\n\n  componentDidUpdate(prevProps: Props) {\n    const {data, extraData} = this.props;\n    if (data !== prevProps.data || extraData !== prevProps.extraData) {\n      // clear the viewableIndices cache to also trigger\n      // the onViewableItemsChanged callback with the new data\n      this._viewabilityTuples.forEach(tuple => {\n        tuple.viewabilityHelper.resetViewableIndices();\n      });\n    }\n    // The `this._hiPriInProgress` is guaranteeing a hiPri cell update will only happen\n    // once per fiber update. The `_scheduleCellsToRenderUpdate` will set it to true\n    // if a hiPri update needs to perform. If `componentDidUpdate` is triggered with\n    // `this._hiPriInProgress=true`, means it's triggered by the hiPri update. The\n    // `_scheduleCellsToRenderUpdate` will check this condition and not perform\n    // another hiPri update.\n    const hiPriInProgress = this._hiPriInProgress;\n    this._scheduleCellsToRenderUpdate();\n    // Make sure setting `this._hiPriInProgress` back to false after `componentDidUpdate`\n    // is triggered with `this._hiPriInProgress = true`\n    if (hiPriInProgress) {\n      this._hiPriInProgress = false;\n    }\n  }\n\n  _averageCellLength = 0;\n  _cellRefs: {[string]: null | CellRenderer<any>} = {};\n  _fillRateHelper: FillRateHelper;\n  _frames: {\n    [string]: {\n      inLayout?: boolean,\n      index: number,\n      length: number,\n      offset: number,\n    },\n  } = {};\n  _footerLength = 0;\n  // Used for preventing scrollToIndex from being called multiple times for initialScrollIndex\n  _hasTriggeredInitialScrollToIndex = false;\n  _hasInteracted = false;\n  _hasMore = false;\n  _hasWarned: {[string]: boolean} = {};\n  _headerLength = 0;\n  _hiPriInProgress: boolean = false; // flag to prevent infinite hiPri cell limit update\n  _highestMeasuredFrameIndex = 0;\n  _indicesToKeys: Map<number, string> = new Map();\n  _lastFocusedCellKey: ?string = null;\n  _nestedChildLists: ChildListCollection<VirtualizedList> =\n    new ChildListCollection();\n  _offsetFromParentVirtualizedList: number = 0;\n  _prevParentOffset: number = 0;\n  // $FlowFixMe[missing-local-annot]\n  _scrollMetrics = {\n    contentLength: 0,\n    dOffset: 0,\n    dt: 10,\n    offset: 0,\n    timestamp: 0,\n    velocity: 0,\n    visibleLength: 0,\n    zoomScale: 1,\n  };\n  _scrollRef: ?React.ElementRef<any> = null;\n  _sentStartForContentLength = 0;\n  _sentEndForContentLength = 0;\n  _totalCellLength = 0;\n  _totalCellsMeasured = 0;\n  _updateCellsToRenderBatcher: Batchinator;\n  _viewabilityTuples: Array<ViewabilityHelperCallbackTuple> = [];\n\n  /* $FlowFixMe[missing-local-annot] The type annotation(s) required by Flow's\n   * LTI update could not be added via codemod */\n  _captureScrollRef = ref => {\n    this._scrollRef = ref;\n  };\n\n  _computeBlankness() {\n    this._fillRateHelper.computeBlankness(\n      this.props,\n      this.state.cellsAroundViewport,\n      this._scrollMetrics,\n    );\n  }\n\n  /* $FlowFixMe[missing-local-annot] The type annotation(s) required by Flow's\n   * LTI update could not be added via codemod */\n  _defaultRenderScrollComponent = props => {\n    const onRefresh = props.onRefresh;\n    if (this._isNestedWithSameOrientation()) {\n      // $FlowFixMe[prop-missing] - Typing ReactNativeComponent revealed errors\n      return <View {...props} />;\n    } else if (onRefresh) {\n      invariant(\n        typeof props.refreshing === 'boolean',\n        '`refreshing` prop must be set as a boolean in order to use `onRefresh`, but got `' +\n          JSON.stringify(props.refreshing ?? 'undefined') +\n          '`',\n      );\n      return (\n        // $FlowFixMe[prop-missing] Invalid prop usage\n        // $FlowFixMe[incompatible-use]\n        <ScrollView\n          {...props}\n          refreshControl={\n            props.refreshControl == null ? (\n              <RefreshControl\n                // $FlowFixMe[incompatible-type]\n                refreshing={props.refreshing}\n                onRefresh={onRefresh}\n                progressViewOffset={props.progressViewOffset}\n              />\n            ) : (\n              props.refreshControl\n            )\n          }\n        />\n      );\n    } else {\n      // $FlowFixMe[prop-missing] Invalid prop usage\n      // $FlowFixMe[incompatible-use]\n      return <ScrollView {...props} />;\n    }\n  };\n\n  _onCellLayout = (e: LayoutEvent, cellKey: string, index: number): void => {\n    const layout = e.nativeEvent.layout;\n    const next = {\n      offset: this._selectOffset(layout),\n      length: this._selectLength(layout),\n      index,\n      inLayout: true,\n    };\n    const curr = this._frames[cellKey];\n    if (\n      !curr ||\n      next.offset !== curr.offset ||\n      next.length !== curr.length ||\n      index !== curr.index\n    ) {\n      this._totalCellLength += next.length - (curr ? curr.length : 0);\n      this._totalCellsMeasured += curr ? 0 : 1;\n      this._averageCellLength =\n        this._totalCellLength / this._totalCellsMeasured;\n      this._frames[cellKey] = next;\n      this._highestMeasuredFrameIndex = Math.max(\n        this._highestMeasuredFrameIndex,\n        index,\n      );\n      this._scheduleCellsToRenderUpdate();\n    } else {\n      this._frames[cellKey].inLayout = true;\n    }\n\n    this._triggerRemeasureForChildListsInCell(cellKey);\n\n    this._computeBlankness();\n    this._updateViewableItems(this.props, this.state.cellsAroundViewport);\n  };\n\n  _onCellFocusCapture(cellKey: string) {\n    this._lastFocusedCellKey = cellKey;\n    this._updateCellsToRender();\n  }\n\n  _onCellUnmount = (cellKey: string) => {\n    delete this._cellRefs[cellKey];\n    const curr = this._frames[cellKey];\n    if (curr) {\n      this._frames[cellKey] = {...curr, inLayout: false};\n    }\n  };\n\n  _triggerRemeasureForChildListsInCell(cellKey: string): void {\n    this._nestedChildLists.forEachInCell(cellKey, childList => {\n      childList.measureLayoutRelativeToContainingList();\n    });\n  }\n\n  measureLayoutRelativeToContainingList(): void {\n    // TODO (T35574538): findNodeHandle sometimes crashes with \"Unable to find\n    // node on an unmounted component\" during scrolling\n    try {\n      if (!this._scrollRef) {\n        return;\n      }\n      // We are assuming that getOutermostParentListRef().getScrollRef()\n      // is a non-null reference to a ScrollView\n      this._scrollRef.measureLayout(\n        this.context.getOutermostParentListRef().getScrollRef(),\n        (x, y, width, height) => {\n          this._offsetFromParentVirtualizedList = this._selectOffset({x, y});\n          this._scrollMetrics.contentLength = this._selectLength({\n            width,\n            height,\n          });\n          const scrollMetrics = this._convertParentScrollMetrics(\n            this.context.getScrollMetrics(),\n          );\n\n          const metricsChanged =\n            this._scrollMetrics.visibleLength !== scrollMetrics.visibleLength ||\n            this._scrollMetrics.offset !== scrollMetrics.offset;\n\n          if (metricsChanged) {\n            this._scrollMetrics.visibleLength = scrollMetrics.visibleLength;\n            this._scrollMetrics.offset = scrollMetrics.offset;\n\n            // If metrics of the scrollView changed, then we triggered remeasure for child list\n            // to ensure VirtualizedList has the right information.\n            this._nestedChildLists.forEach(childList => {\n              childList.measureLayoutRelativeToContainingList();\n            });\n          }\n        },\n        error => {\n          console.warn(\n            \"VirtualizedList: Encountered an error while measuring a list's\" +\n              ' offset from its containing VirtualizedList.',\n          );\n        },\n      );\n    } catch (error) {\n      console.warn(\n        'measureLayoutRelativeToContainingList threw an error',\n        error.stack,\n      );\n    }\n  }\n\n  _onLayout = (e: LayoutEvent) => {\n    if (this._isNestedWithSameOrientation()) {\n      // Need to adjust our scroll metrics to be relative to our containing\n      // VirtualizedList before we can make claims about list item viewability\n      this.measureLayoutRelativeToContainingList();\n    } else {\n      this._scrollMetrics.visibleLength = this._selectLength(\n        e.nativeEvent.layout,\n      );\n    }\n    this.props.onLayout && this.props.onLayout(e);\n    this._scheduleCellsToRenderUpdate();\n    this._maybeCallOnEdgeReached();\n  };\n\n  _onLayoutEmpty = (e: LayoutEvent) => {\n    this.props.onLayout && this.props.onLayout(e);\n  };\n\n  _getFooterCellKey(): string {\n    return this._getCellKey() + '-footer';\n  }\n\n  _onLayoutFooter = (e: LayoutEvent) => {\n    this._triggerRemeasureForChildListsInCell(this._getFooterCellKey());\n    this._footerLength = this._selectLength(e.nativeEvent.layout);\n  };\n\n  _onLayoutHeader = (e: LayoutEvent) => {\n    this._headerLength = this._selectLength(e.nativeEvent.layout);\n  };\n\n  // $FlowFixMe[missing-local-annot]\n  _renderDebugOverlay() {\n    const normalize =\n      this._scrollMetrics.visibleLength /\n      (this._scrollMetrics.contentLength || 1);\n    const framesInLayout = [];\n    const itemCount = this.props.getItemCount(this.props.data);\n    for (let ii = 0; ii < itemCount; ii++) {\n      const frame = this.__getFrameMetricsApprox(ii, this.props);\n      /* $FlowFixMe[prop-missing] (>=0.68.0 site=react_native_fb) This comment\n       * suppresses an error found when Flow v0.68 was deployed. To see the\n       * error delete this comment and run Flow. */\n      if (frame.inLayout) {\n        framesInLayout.push(frame);\n      }\n    }\n    const windowTop = this.__getFrameMetricsApprox(\n      this.state.cellsAroundViewport.first,\n      this.props,\n    ).offset;\n    const frameLast = this.__getFrameMetricsApprox(\n      this.state.cellsAroundViewport.last,\n      this.props,\n    );\n    const windowLen = frameLast.offset + frameLast.length - windowTop;\n    const visTop = this._scrollMetrics.offset;\n    const visLen = this._scrollMetrics.visibleLength;\n\n    return (\n      <View style={[styles.debugOverlayBase, styles.debugOverlay]}>\n        {framesInLayout.map((f, ii) => (\n          <View\n            key={'f' + ii}\n            style={[\n              styles.debugOverlayBase,\n              styles.debugOverlayFrame,\n              {\n                top: f.offset * normalize,\n                height: f.length * normalize,\n              },\n            ]}\n          />\n        ))}\n        <View\n          style={[\n            styles.debugOverlayBase,\n            styles.debugOverlayFrameLast,\n            {\n              top: windowTop * normalize,\n              height: windowLen * normalize,\n            },\n          ]}\n        />\n        <View\n          style={[\n            styles.debugOverlayBase,\n            styles.debugOverlayFrameVis,\n            {\n              top: visTop * normalize,\n              height: visLen * normalize,\n            },\n          ]}\n        />\n      </View>\n    );\n  }\n\n  _selectLength(\n    metrics: $ReadOnly<{\n      height: number,\n      width: number,\n      ...\n    }>,\n  ): number {\n    return !horizontalOrDefault(this.props.horizontal)\n      ? metrics.height\n      : metrics.width;\n  }\n\n  _selectOffset(\n    metrics: $ReadOnly<{\n      x: number,\n      y: number,\n      ...\n    }>,\n  ): number {\n    return !horizontalOrDefault(this.props.horizontal) ? metrics.y : metrics.x;\n  }\n\n  _maybeCallOnEdgeReached() {\n    const {\n      data,\n      getItemCount,\n      onStartReached,\n      onStartReachedThreshold,\n      onEndReached,\n      onEndReachedThreshold,\n    } = this.props;\n    // If we have any pending scroll updates it means that the scroll metrics\n    // are out of date and we should not call any of the edge reached callbacks.\n    if (this.state.pendingScrollUpdateCount > 0) {\n      return;\n    }\n\n    const {contentLength, visibleLength, offset} = this._scrollMetrics;\n    let distanceFromStart = offset;\n    let distanceFromEnd = contentLength - visibleLength - offset;\n\n    // Especially when oERT is zero it's necessary to 'floor' very small distance values to be 0\n    // since debouncing causes us to not fire this event for every single \"pixel\" we scroll and can thus\n    // be at the edge of the list with a distance approximating 0 but not quite there.\n    if (distanceFromStart < ON_EDGE_REACHED_EPSILON) {\n      distanceFromStart = 0;\n    }\n    if (distanceFromEnd < ON_EDGE_REACHED_EPSILON) {\n      distanceFromEnd = 0;\n    }\n\n    // TODO: T121172172 Look into why we're \"defaulting\" to a threshold of 2px\n    // when oERT is not present (different from 2 viewports used elsewhere)\n    const DEFAULT_THRESHOLD_PX = 2;\n\n    const startThreshold =\n      onStartReachedThreshold != null\n        ? onStartReachedThreshold * visibleLength\n        : DEFAULT_THRESHOLD_PX;\n    const endThreshold =\n      onEndReachedThreshold != null\n        ? onEndReachedThreshold * visibleLength\n        : DEFAULT_THRESHOLD_PX;\n    const isWithinStartThreshold = distanceFromStart <= startThreshold;\n    const isWithinEndThreshold = distanceFromEnd <= endThreshold;\n\n    // First check if the user just scrolled within the end threshold\n    // and call onEndReached only once for a given content length,\n    // and only if onStartReached is not being executed\n    if (\n      onEndReached &&\n      this.state.cellsAroundViewport.last === getItemCount(data) - 1 &&\n      isWithinEndThreshold &&\n      this._scrollMetrics.contentLength !== this._sentEndForContentLength\n    ) {\n      this._sentEndForContentLength = this._scrollMetrics.contentLength;\n      onEndReached({distanceFromEnd});\n    }\n\n    // Next check if the user just scrolled within the start threshold\n    // and call onStartReached only once for a given content length,\n    // and only if onEndReached is not being executed\n    else if (\n      onStartReached != null &&\n      this.state.cellsAroundViewport.first === 0 &&\n      isWithinStartThreshold &&\n      this._scrollMetrics.contentLength !== this._sentStartForContentLength\n    ) {\n      this._sentStartForContentLength = this._scrollMetrics.contentLength;\n      onStartReached({distanceFromStart});\n    }\n\n    // If the user scrolls away from the start or end and back again,\n    // cause onStartReached or onEndReached to be triggered again\n    else {\n      this._sentStartForContentLength = isWithinStartThreshold\n        ? this._sentStartForContentLength\n        : 0;\n      this._sentEndForContentLength = isWithinEndThreshold\n        ? this._sentEndForContentLength\n        : 0;\n    }\n  }\n\n  _onContentSizeChange = (width: number, height: number) => {\n    if (\n      width > 0 &&\n      height > 0 &&\n      this.props.initialScrollIndex != null &&\n      this.props.initialScrollIndex > 0 &&\n      !this._hasTriggeredInitialScrollToIndex\n    ) {\n      if (this.props.contentOffset == null) {\n        if (\n          this.props.initialScrollIndex <\n          this.props.getItemCount(this.props.data)\n        ) {\n          this.scrollToIndex({\n            animated: false,\n            index: nullthrows(this.props.initialScrollIndex),\n          });\n        } else {\n          this.scrollToEnd({animated: false});\n        }\n      }\n      this._hasTriggeredInitialScrollToIndex = true;\n    }\n    if (this.props.onContentSizeChange) {\n      this.props.onContentSizeChange(width, height);\n    }\n    this._scrollMetrics.contentLength = this._selectLength({height, width});\n    this._scheduleCellsToRenderUpdate();\n    this._maybeCallOnEdgeReached();\n  };\n\n  /* Translates metrics from a scroll event in a parent VirtualizedList into\n   * coordinates relative to the child list.\n   */\n  _convertParentScrollMetrics = (metrics: {\n    visibleLength: number,\n    offset: number,\n    ...\n  }): $FlowFixMe => {\n    // Offset of the top of the nested list relative to the top of its parent's viewport\n    const offset = metrics.offset - this._offsetFromParentVirtualizedList;\n    // Child's visible length is the same as its parent's\n    const visibleLength = metrics.visibleLength;\n    const dOffset = offset - this._scrollMetrics.offset;\n    const contentLength = this._scrollMetrics.contentLength;\n\n    return {\n      visibleLength,\n      contentLength,\n      offset,\n      dOffset,\n    };\n  };\n\n  _onScroll = (e: Object) => {\n    this._nestedChildLists.forEach(childList => {\n      childList._onScroll(e);\n    });\n    if (this.props.onScroll) {\n      this.props.onScroll(e);\n    }\n    const timestamp = e.timeStamp;\n    let visibleLength = this._selectLength(e.nativeEvent.layoutMeasurement);\n    let contentLength = this._selectLength(e.nativeEvent.contentSize);\n    let offset = this._selectOffset(e.nativeEvent.contentOffset);\n    let dOffset = offset - this._scrollMetrics.offset;\n\n    if (this._isNestedWithSameOrientation()) {\n      if (this._scrollMetrics.contentLength === 0) {\n        // Ignore scroll events until onLayout has been called and we\n        // know our offset from our offset from our parent\n        return;\n      }\n      ({visibleLength, contentLength, offset, dOffset} =\n        this._convertParentScrollMetrics({\n          visibleLength,\n          offset,\n        }));\n    }\n\n    const dt = this._scrollMetrics.timestamp\n      ? Math.max(1, timestamp - this._scrollMetrics.timestamp)\n      : 1;\n    const velocity = dOffset / dt;\n\n    if (\n      dt > 500 &&\n      this._scrollMetrics.dt > 500 &&\n      contentLength > 5 * visibleLength &&\n      !this._hasWarned.perf\n    ) {\n      infoLog(\n        'VirtualizedList: You have a large list that is slow to update - make sure your ' +\n          'renderItem function renders components that follow React performance best practices ' +\n          'like PureComponent, shouldComponentUpdate, etc.',\n        {dt, prevDt: this._scrollMetrics.dt, contentLength},\n      );\n      this._hasWarned.perf = true;\n    }\n\n    // For invalid negative values (w/ RTL), set this to 1.\n    const zoomScale = e.nativeEvent.zoomScale < 0 ? 1 : e.nativeEvent.zoomScale;\n    this._scrollMetrics = {\n      contentLength,\n      dt,\n      dOffset,\n      offset,\n      timestamp,\n      velocity,\n      visibleLength,\n      zoomScale,\n    };\n    if (this.state.pendingScrollUpdateCount > 0) {\n      this.setState(state => ({\n        pendingScrollUpdateCount: state.pendingScrollUpdateCount - 1,\n      }));\n    }\n    this._updateViewableItems(this.props, this.state.cellsAroundViewport);\n    if (!this.props) {\n      return;\n    }\n    this._maybeCallOnEdgeReached();\n    if (velocity !== 0) {\n      this._fillRateHelper.activate();\n    }\n    this._computeBlankness();\n    this._scheduleCellsToRenderUpdate();\n  };\n\n  _scheduleCellsToRenderUpdate() {\n    const {first, last} = this.state.cellsAroundViewport;\n    const {offset, visibleLength, velocity} = this._scrollMetrics;\n    const itemCount = this.props.getItemCount(this.props.data);\n    let hiPri = false;\n    const onStartReachedThreshold = onStartReachedThresholdOrDefault(\n      this.props.onStartReachedThreshold,\n    );\n    const onEndReachedThreshold = onEndReachedThresholdOrDefault(\n      this.props.onEndReachedThreshold,\n    );\n    // Mark as high priority if we're close to the start of the first item\n    // But only if there are items before the first rendered item\n    if (first > 0) {\n      const distTop =\n        offset - this.__getFrameMetricsApprox(first, this.props).offset;\n      hiPri =\n        distTop < 0 ||\n        (velocity < -2 &&\n          distTop <\n            getScrollingThreshold(onStartReachedThreshold, visibleLength));\n    }\n    // Mark as high priority if we're close to the end of the last item\n    // But only if there are items after the last rendered item\n    if (!hiPri && last >= 0 && last < itemCount - 1) {\n      const distBottom =\n        this.__getFrameMetricsApprox(last, this.props).offset -\n        (offset + visibleLength);\n      hiPri =\n        distBottom < 0 ||\n        (velocity > 2 &&\n          distBottom <\n            getScrollingThreshold(onEndReachedThreshold, visibleLength));\n    }\n    // Only trigger high-priority updates if we've actually rendered cells,\n    // and with that size estimate, accurately compute how many cells we should render.\n    // Otherwise, it would just render as many cells as it can (of zero dimension),\n    // each time through attempting to render more (limited by maxToRenderPerBatch),\n    // starving the renderer from actually laying out the objects and computing _averageCellLength.\n    // If this is triggered in an `componentDidUpdate` followed by a hiPri cellToRenderUpdate\n    // We shouldn't do another hipri cellToRenderUpdate\n    if (\n      hiPri &&\n      (this._averageCellLength || this.props.getItemLayout) &&\n      !this._hiPriInProgress\n    ) {\n      this._hiPriInProgress = true;\n      // Don't worry about interactions when scrolling quickly; focus on filling content as fast\n      // as possible.\n      this._updateCellsToRenderBatcher.dispose({abort: true});\n      this._updateCellsToRender();\n      return;\n    } else {\n      this._updateCellsToRenderBatcher.schedule();\n    }\n  }\n\n  _onScrollBeginDrag = (e: ScrollEvent): void => {\n    this._nestedChildLists.forEach(childList => {\n      childList._onScrollBeginDrag(e);\n    });\n    this._viewabilityTuples.forEach(tuple => {\n      tuple.viewabilityHelper.recordInteraction();\n    });\n    this._hasInteracted = true;\n    this.props.onScrollBeginDrag && this.props.onScrollBeginDrag(e);\n  };\n\n  _onScrollEndDrag = (e: ScrollEvent): void => {\n    this._nestedChildLists.forEach(childList => {\n      childList._onScrollEndDrag(e);\n    });\n    const {velocity} = e.nativeEvent;\n    if (velocity) {\n      this._scrollMetrics.velocity = this._selectOffset(velocity);\n    }\n    this._computeBlankness();\n    this.props.onScrollEndDrag && this.props.onScrollEndDrag(e);\n  };\n\n  _onMomentumScrollBegin = (e: ScrollEvent): void => {\n    this._nestedChildLists.forEach(childList => {\n      childList._onMomentumScrollBegin(e);\n    });\n    this.props.onMomentumScrollBegin && this.props.onMomentumScrollBegin(e);\n  };\n\n  _onMomentumScrollEnd = (e: ScrollEvent): void => {\n    this._nestedChildLists.forEach(childList => {\n      childList._onMomentumScrollEnd(e);\n    });\n    this._scrollMetrics.velocity = 0;\n    this._computeBlankness();\n    this.props.onMomentumScrollEnd && this.props.onMomentumScrollEnd(e);\n  };\n\n  _updateCellsToRender = () => {\n    this._updateViewableItems(this.props, this.state.cellsAroundViewport);\n\n    this.setState((state, props) => {\n      const cellsAroundViewport = this._adjustCellsAroundViewport(\n        props,\n        state.cellsAroundViewport,\n        state.pendingScrollUpdateCount,\n      );\n      const renderMask = VirtualizedList._createRenderMask(\n        props,\n        cellsAroundViewport,\n        this._getNonViewportRenderRegions(props),\n      );\n\n      if (\n        cellsAroundViewport.first === state.cellsAroundViewport.first &&\n        cellsAroundViewport.last === state.cellsAroundViewport.last &&\n        renderMask.equals(state.renderMask)\n      ) {\n        return null;\n      }\n\n      return {cellsAroundViewport, renderMask};\n    });\n  };\n\n  _createViewToken = (\n    index: number,\n    isViewable: boolean,\n    props: FrameMetricProps,\n    // $FlowFixMe[missing-local-annot]\n  ) => {\n    const {data, getItem} = props;\n    const item = getItem(data, index);\n    return {\n      index,\n      item,\n      key: VirtualizedList._keyExtractor(item, index, props),\n      isViewable,\n    };\n  };\n\n  /**\n   * Gets an approximate offset to an item at a given index. Supports\n   * fractional indices.\n   */\n  _getOffsetApprox = (index: number, props: FrameMetricProps): number => {\n    if (Number.isInteger(index)) {\n      return this.__getFrameMetricsApprox(index, props).offset;\n    } else {\n      const frameMetrics = this.__getFrameMetricsApprox(\n        Math.floor(index),\n        props,\n      );\n      const remainder = index - Math.floor(index);\n      return frameMetrics.offset + remainder * frameMetrics.length;\n    }\n  };\n\n  __getFrameMetricsApprox: (\n    index: number,\n    props: FrameMetricProps,\n  ) => {\n    length: number,\n    offset: number,\n    ...\n  } = (index, props) => {\n    const frame = this._getFrameMetrics(index, props);\n    if (frame && frame.index === index) {\n      // check for invalid frames due to row re-ordering\n      return frame;\n    } else {\n      const {data, getItemCount, getItemLayout} = props;\n      invariant(\n        index >= 0 && index < getItemCount(data),\n        'Tried to get frame for out of range index ' + index,\n      );\n      invariant(\n        !getItemLayout,\n        'Should not have to estimate frames when a measurement metrics function is provided',\n      );\n      return {\n        length: this._averageCellLength,\n        offset: this._averageCellLength * index,\n      };\n    }\n  };\n\n  _getFrameMetrics = (\n    index: number,\n    props: FrameMetricProps,\n  ): ?{\n    length: number,\n    offset: number,\n    index: number,\n    inLayout?: boolean,\n    ...\n  } => {\n    const {data, getItemCount, getItemLayout} = props;\n    invariant(\n      index >= 0 && index < getItemCount(data),\n      'Tried to get frame for out of range index ' + index,\n    );\n    const frame = this._frames[VirtualizedList._getItemKey(props, index)];\n    if (!frame || frame.index !== index) {\n      if (getItemLayout) {\n        /* $FlowFixMe[prop-missing] (>=0.63.0 site=react_native_fb) This comment\n         * suppresses an error found when Flow v0.63 was deployed. To see the error\n         * delete this comment and run Flow. */\n        return getItemLayout(data, index);\n      }\n    }\n    return frame;\n  };\n\n  _getNonViewportRenderRegions = (\n    props: FrameMetricProps,\n  ): $ReadOnlyArray<{\n    first: number,\n    last: number,\n  }> => {\n    // Keep a viewport's worth of content around the last focused cell to allow\n    // random navigation around it without any blanking. E.g. tabbing from one\n    // focused item out of viewport to another.\n    if (\n      !(this._lastFocusedCellKey && this._cellRefs[this._lastFocusedCellKey])\n    ) {\n      return [];\n    }\n\n    const lastFocusedCellRenderer = this._cellRefs[this._lastFocusedCellKey];\n    const focusedCellIndex = lastFocusedCellRenderer.props.index;\n    const itemCount = props.getItemCount(props.data);\n\n    // The last cell we rendered may be at a new index. Bail if we don't know\n    // where it is.\n    if (\n      focusedCellIndex >= itemCount ||\n      VirtualizedList._getItemKey(props, focusedCellIndex) !==\n        this._lastFocusedCellKey\n    ) {\n      return [];\n    }\n\n    let first = focusedCellIndex;\n    let heightOfCellsBeforeFocused = 0;\n    for (\n      let i = first - 1;\n      i >= 0 && heightOfCellsBeforeFocused < this._scrollMetrics.visibleLength;\n      i--\n    ) {\n      first--;\n      heightOfCellsBeforeFocused += this.__getFrameMetricsApprox(\n        i,\n        props,\n      ).length;\n    }\n\n    let last = focusedCellIndex;\n    let heightOfCellsAfterFocused = 0;\n    for (\n      let i = last + 1;\n      i < itemCount &&\n      heightOfCellsAfterFocused < this._scrollMetrics.visibleLength;\n      i++\n    ) {\n      last++;\n      heightOfCellsAfterFocused += this.__getFrameMetricsApprox(\n        i,\n        props,\n      ).length;\n    }\n\n    return [{first, last}];\n  };\n\n  _updateViewableItems(\n    props: FrameMetricProps,\n    cellsAroundViewport: {first: number, last: number},\n  ) {\n    // If we have any pending scroll updates it means that the scroll metrics\n    // are out of date and we should not call any of the visibility callbacks.\n    if (this.state.pendingScrollUpdateCount > 0) {\n      return;\n    }\n    this._viewabilityTuples.forEach(tuple => {\n      tuple.viewabilityHelper.onUpdate(\n        props,\n        this._scrollMetrics.offset,\n        this._scrollMetrics.visibleLength,\n        this._getFrameMetrics,\n        this._createViewToken,\n        tuple.onViewableItemsChanged,\n        cellsAroundViewport,\n      );\n    });\n  }\n}\n\nconst styles = StyleSheet.create({\n  verticallyInverted:\n    Platform.OS === 'android'\n      ? {transform: [{scale: -1}]}\n      : {transform: [{scaleY: -1}]},\n  horizontallyInverted: {\n    transform: [{scaleX: -1}],\n  },\n  debug: {\n    flex: 1,\n  },\n  debugOverlayBase: {\n    position: 'absolute',\n    top: 0,\n    right: 0,\n  },\n  debugOverlay: {\n    bottom: 0,\n    width: 20,\n    borderColor: 'blue',\n    borderWidth: 1,\n  },\n  debugOverlayFrame: {\n    left: 0,\n    backgroundColor: 'orange',\n  },\n  debugOverlayFrameLast: {\n    left: 0,\n    borderColor: 'green',\n    borderWidth: 2,\n  },\n  debugOverlayFrameVis: {\n    left: 0,\n    borderColor: 'red',\n    borderWidth: 2,\n  },\n});\n\nmodule.exports = VirtualizedList;\n"],"mappings":"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","ignoreList":[]},"metadata":{"hasCjsExports":true},"sourceType":"module","externalDependencies":[]}