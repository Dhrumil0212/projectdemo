{"ast":null,"code":"import SoundManager from '../Components/Sound/SoundManager';\nimport ReactNativeFeatureFlags from '../ReactNative/ReactNativeFeatureFlags';\nimport UIManager from '../ReactNative/UIManager';\nimport { normalizeRect } from '../StyleSheet/Rect';\nimport Platform from '../Utilities/Platform';\nimport { isHoverEnabled } from './HoverState';\nimport PressabilityPerformanceEventEmitter from './PressabilityPerformanceEventEmitter.js';\nimport invariant from 'invariant';\nimport * as React from 'react';\nconst Transitions = Object.freeze({\n  NOT_RESPONDER: {\n    DELAY: 'ERROR',\n    RESPONDER_GRANT: 'RESPONDER_INACTIVE_PRESS_IN',\n    RESPONDER_RELEASE: 'ERROR',\n    RESPONDER_TERMINATED: 'ERROR',\n    ENTER_PRESS_RECT: 'ERROR',\n    LEAVE_PRESS_RECT: 'ERROR',\n    LONG_PRESS_DETECTED: 'ERROR'\n  },\n  RESPONDER_INACTIVE_PRESS_IN: {\n    DELAY: 'RESPONDER_ACTIVE_PRESS_IN',\n    RESPONDER_GRANT: 'ERROR',\n    RESPONDER_RELEASE: 'NOT_RESPONDER',\n    RESPONDER_TERMINATED: 'NOT_RESPONDER',\n    ENTER_PRESS_RECT: 'RESPONDER_INACTIVE_PRESS_IN',\n    LEAVE_PRESS_RECT: 'RESPONDER_INACTIVE_PRESS_OUT',\n    LONG_PRESS_DETECTED: 'ERROR'\n  },\n  RESPONDER_INACTIVE_PRESS_OUT: {\n    DELAY: 'RESPONDER_ACTIVE_PRESS_OUT',\n    RESPONDER_GRANT: 'ERROR',\n    RESPONDER_RELEASE: 'NOT_RESPONDER',\n    RESPONDER_TERMINATED: 'NOT_RESPONDER',\n    ENTER_PRESS_RECT: 'RESPONDER_INACTIVE_PRESS_IN',\n    LEAVE_PRESS_RECT: 'RESPONDER_INACTIVE_PRESS_OUT',\n    LONG_PRESS_DETECTED: 'ERROR'\n  },\n  RESPONDER_ACTIVE_PRESS_IN: {\n    DELAY: 'ERROR',\n    RESPONDER_GRANT: 'ERROR',\n    RESPONDER_RELEASE: 'NOT_RESPONDER',\n    RESPONDER_TERMINATED: 'NOT_RESPONDER',\n    ENTER_PRESS_RECT: 'RESPONDER_ACTIVE_PRESS_IN',\n    LEAVE_PRESS_RECT: 'RESPONDER_ACTIVE_PRESS_OUT',\n    LONG_PRESS_DETECTED: 'RESPONDER_ACTIVE_LONG_PRESS_IN'\n  },\n  RESPONDER_ACTIVE_PRESS_OUT: {\n    DELAY: 'ERROR',\n    RESPONDER_GRANT: 'ERROR',\n    RESPONDER_RELEASE: 'NOT_RESPONDER',\n    RESPONDER_TERMINATED: 'NOT_RESPONDER',\n    ENTER_PRESS_RECT: 'RESPONDER_ACTIVE_PRESS_IN',\n    LEAVE_PRESS_RECT: 'RESPONDER_ACTIVE_PRESS_OUT',\n    LONG_PRESS_DETECTED: 'ERROR'\n  },\n  RESPONDER_ACTIVE_LONG_PRESS_IN: {\n    DELAY: 'ERROR',\n    RESPONDER_GRANT: 'ERROR',\n    RESPONDER_RELEASE: 'NOT_RESPONDER',\n    RESPONDER_TERMINATED: 'NOT_RESPONDER',\n    ENTER_PRESS_RECT: 'RESPONDER_ACTIVE_LONG_PRESS_IN',\n    LEAVE_PRESS_RECT: 'RESPONDER_ACTIVE_LONG_PRESS_OUT',\n    LONG_PRESS_DETECTED: 'RESPONDER_ACTIVE_LONG_PRESS_IN'\n  },\n  RESPONDER_ACTIVE_LONG_PRESS_OUT: {\n    DELAY: 'ERROR',\n    RESPONDER_GRANT: 'ERROR',\n    RESPONDER_RELEASE: 'NOT_RESPONDER',\n    RESPONDER_TERMINATED: 'NOT_RESPONDER',\n    ENTER_PRESS_RECT: 'RESPONDER_ACTIVE_LONG_PRESS_IN',\n    LEAVE_PRESS_RECT: 'RESPONDER_ACTIVE_LONG_PRESS_OUT',\n    LONG_PRESS_DETECTED: 'ERROR'\n  },\n  ERROR: {\n    DELAY: 'NOT_RESPONDER',\n    RESPONDER_GRANT: 'RESPONDER_INACTIVE_PRESS_IN',\n    RESPONDER_RELEASE: 'NOT_RESPONDER',\n    RESPONDER_TERMINATED: 'NOT_RESPONDER',\n    ENTER_PRESS_RECT: 'NOT_RESPONDER',\n    LEAVE_PRESS_RECT: 'NOT_RESPONDER',\n    LONG_PRESS_DETECTED: 'NOT_RESPONDER'\n  }\n});\nconst isActiveSignal = signal => signal === 'RESPONDER_ACTIVE_PRESS_IN' || signal === 'RESPONDER_ACTIVE_LONG_PRESS_IN';\nconst isActivationSignal = signal => signal === 'RESPONDER_ACTIVE_PRESS_OUT' || signal === 'RESPONDER_ACTIVE_PRESS_IN';\nconst isPressInSignal = signal => signal === 'RESPONDER_INACTIVE_PRESS_IN' || signal === 'RESPONDER_ACTIVE_PRESS_IN' || signal === 'RESPONDER_ACTIVE_LONG_PRESS_IN';\nconst isTerminalSignal = signal => signal === 'RESPONDER_TERMINATED' || signal === 'RESPONDER_RELEASE';\nconst DEFAULT_LONG_PRESS_DELAY_MS = 500;\nconst DEFAULT_PRESS_RECT_OFFSETS = {\n  bottom: 30,\n  left: 20,\n  right: 20,\n  top: 20\n};\nconst DEFAULT_MIN_PRESS_DURATION = 130;\nconst DEFAULT_LONG_PRESS_DEACTIVATION_DISTANCE = 10;\nlet longPressDeactivationDistance = DEFAULT_LONG_PRESS_DEACTIVATION_DISTANCE;\nexport default class Pressability {\n  _eventHandlers = null;\n  _hoverInDelayTimeout = null;\n  _hoverOutDelayTimeout = null;\n  _isHovered = false;\n  _longPressDelayTimeout = null;\n  _pressDelayTimeout = null;\n  _pressOutDelayTimeout = null;\n  _responderID = null;\n  _responderRegion = null;\n  _touchState = 'NOT_RESPONDER';\n  constructor(config) {\n    this.configure(config);\n  }\n  configure(config) {\n    this._config = config;\n  }\n  reset() {\n    this._cancelHoverInDelayTimeout();\n    this._cancelHoverOutDelayTimeout();\n    this._cancelLongPressDelayTimeout();\n    this._cancelPressDelayTimeout();\n    this._cancelPressOutDelayTimeout();\n    this._config = Object.freeze({});\n  }\n  getEventHandlers() {\n    if (this._eventHandlers == null) {\n      this._eventHandlers = this._createEventHandlers();\n    }\n    return this._eventHandlers;\n  }\n  static setLongPressDeactivationDistance(distance) {\n    longPressDeactivationDistance = distance;\n  }\n  _createEventHandlers() {\n    const focusEventHandlers = {\n      onBlur: event => {\n        const {\n          onBlur\n        } = this._config;\n        if (onBlur != null) {\n          onBlur(event);\n        }\n      },\n      onFocus: event => {\n        const {\n          onFocus\n        } = this._config;\n        if (onFocus != null) {\n          onFocus(event);\n        }\n      }\n    };\n    const responderEventHandlers = {\n      onStartShouldSetResponder: () => {\n        const {\n          disabled\n        } = this._config;\n        if (disabled == null) {\n          const {\n            onStartShouldSetResponder_DEPRECATED\n          } = this._config;\n          return onStartShouldSetResponder_DEPRECATED == null ? true : onStartShouldSetResponder_DEPRECATED();\n        }\n        return !disabled;\n      },\n      onResponderGrant: event => {\n        event.persist();\n        this._cancelPressOutDelayTimeout();\n        this._responderID = event.currentTarget;\n        this._touchState = 'NOT_RESPONDER';\n        this._receiveSignal('RESPONDER_GRANT', event);\n        const delayPressIn = normalizeDelay(this._config.delayPressIn);\n        if (delayPressIn > 0) {\n          this._pressDelayTimeout = setTimeout(() => {\n            this._receiveSignal('DELAY', event);\n          }, delayPressIn);\n        } else {\n          this._receiveSignal('DELAY', event);\n        }\n        const delayLongPress = normalizeDelay(this._config.delayLongPress, 10, DEFAULT_LONG_PRESS_DELAY_MS - delayPressIn);\n        this._longPressDelayTimeout = setTimeout(() => {\n          this._handleLongPress(event);\n        }, delayLongPress + delayPressIn);\n      },\n      onResponderMove: event => {\n        const {\n          onPressMove\n        } = this._config;\n        if (onPressMove != null) {\n          onPressMove(event);\n        }\n        const responderRegion = this._responderRegion;\n        if (responderRegion == null) {\n          return;\n        }\n        const touch = getTouchFromPressEvent(event);\n        if (touch == null) {\n          this._cancelLongPressDelayTimeout();\n          this._receiveSignal('LEAVE_PRESS_RECT', event);\n          return;\n        }\n        if (this._touchActivatePosition != null) {\n          const deltaX = this._touchActivatePosition.pageX - touch.pageX;\n          const deltaY = this._touchActivatePosition.pageY - touch.pageY;\n          if (Math.hypot(deltaX, deltaY) > longPressDeactivationDistance) {\n            this._cancelLongPressDelayTimeout();\n          }\n        }\n        if (this._isTouchWithinResponderRegion(touch, responderRegion)) {\n          this._receiveSignal('ENTER_PRESS_RECT', event);\n        } else {\n          this._cancelLongPressDelayTimeout();\n          this._receiveSignal('LEAVE_PRESS_RECT', event);\n        }\n      },\n      onResponderRelease: event => {\n        this._receiveSignal('RESPONDER_RELEASE', event);\n      },\n      onResponderTerminate: event => {\n        this._receiveSignal('RESPONDER_TERMINATED', event);\n      },\n      onResponderTerminationRequest: () => {\n        const {\n          cancelable\n        } = this._config;\n        if (cancelable == null) {\n          const {\n            onResponderTerminationRequest_DEPRECATED\n          } = this._config;\n          return onResponderTerminationRequest_DEPRECATED == null ? true : onResponderTerminationRequest_DEPRECATED();\n        }\n        return cancelable;\n      },\n      onClick: event => {\n        const {\n          onPress,\n          disabled\n        } = this._config;\n        if (onPress != null && disabled !== true) {\n          onPress(event);\n        }\n      }\n    };\n    if (process.env.NODE_ENV === 'test') {\n      responderEventHandlers.onStartShouldSetResponder.testOnly_pressabilityConfig = () => this._config;\n    }\n    if (ReactNativeFeatureFlags.shouldPressibilityUseW3CPointerEventsForHover()) {\n      const hoverPointerEvents = {\n        onPointerEnter: undefined,\n        onPointerLeave: undefined\n      };\n      const {\n        onHoverIn,\n        onHoverOut\n      } = this._config;\n      if (onHoverIn != null) {\n        hoverPointerEvents.onPointerEnter = event => {\n          this._isHovered = true;\n          this._cancelHoverOutDelayTimeout();\n          if (onHoverIn != null) {\n            const delayHoverIn = normalizeDelay(this._config.delayHoverIn);\n            if (delayHoverIn > 0) {\n              event.persist();\n              this._hoverInDelayTimeout = setTimeout(() => {\n                onHoverIn(convertPointerEventToMouseEvent(event));\n              }, delayHoverIn);\n            } else {\n              onHoverIn(convertPointerEventToMouseEvent(event));\n            }\n          }\n        };\n      }\n      if (onHoverOut != null) {\n        hoverPointerEvents.onPointerLeave = event => {\n          if (this._isHovered) {\n            this._isHovered = false;\n            this._cancelHoverInDelayTimeout();\n            if (onHoverOut != null) {\n              const delayHoverOut = normalizeDelay(this._config.delayHoverOut);\n              if (delayHoverOut > 0) {\n                event.persist();\n                this._hoverOutDelayTimeout = setTimeout(() => {\n                  onHoverOut(convertPointerEventToMouseEvent(event));\n                }, delayHoverOut);\n              } else {\n                onHoverOut(convertPointerEventToMouseEvent(event));\n              }\n            }\n          }\n        };\n      }\n      return Object.assign({}, focusEventHandlers, responderEventHandlers, hoverPointerEvents);\n    } else {\n      const mouseEventHandlers = Platform.OS === 'ios' || Platform.OS === 'android' ? null : {\n        onMouseEnter: event => {\n          if (isHoverEnabled()) {\n            this._isHovered = true;\n            this._cancelHoverOutDelayTimeout();\n            const {\n              onHoverIn\n            } = this._config;\n            if (onHoverIn != null) {\n              const delayHoverIn = normalizeDelay(this._config.delayHoverIn);\n              if (delayHoverIn > 0) {\n                event.persist();\n                this._hoverInDelayTimeout = setTimeout(() => {\n                  onHoverIn(event);\n                }, delayHoverIn);\n              } else {\n                onHoverIn(event);\n              }\n            }\n          }\n        },\n        onMouseLeave: event => {\n          if (this._isHovered) {\n            this._isHovered = false;\n            this._cancelHoverInDelayTimeout();\n            const {\n              onHoverOut\n            } = this._config;\n            if (onHoverOut != null) {\n              const delayHoverOut = normalizeDelay(this._config.delayHoverOut);\n              if (delayHoverOut > 0) {\n                event.persist();\n                this._hoverInDelayTimeout = setTimeout(() => {\n                  onHoverOut(event);\n                }, delayHoverOut);\n              } else {\n                onHoverOut(event);\n              }\n            }\n          }\n        }\n      };\n      return Object.assign({}, focusEventHandlers, responderEventHandlers, mouseEventHandlers);\n    }\n  }\n  _receiveSignal(signal, event) {\n    if (event.nativeEvent.timestamp != null) {\n      PressabilityPerformanceEventEmitter.emitEvent(() => {\n        return {\n          signal,\n          nativeTimestamp: event.nativeEvent.timestamp\n        };\n      });\n    }\n    const prevState = this._touchState;\n    const nextState = Transitions[prevState]?.[signal];\n    if (this._responderID == null && signal === 'RESPONDER_RELEASE') {\n      return;\n    }\n    invariant(nextState != null && nextState !== 'ERROR', 'Pressability: Invalid signal `%s` for state `%s` on responder: %s', signal, prevState, typeof this._responderID === 'number' ? this._responderID : '<<host component>>');\n    if (prevState !== nextState) {\n      this._performTransitionSideEffects(prevState, nextState, signal, event);\n      this._touchState = nextState;\n    }\n  }\n  _performTransitionSideEffects(prevState, nextState, signal, event) {\n    if (isTerminalSignal(signal)) {\n      this._touchActivatePosition = null;\n      this._cancelLongPressDelayTimeout();\n    }\n    const isInitialTransition = prevState === 'NOT_RESPONDER' && nextState === 'RESPONDER_INACTIVE_PRESS_IN';\n    const isActivationTransition = !isActivationSignal(prevState) && isActivationSignal(nextState);\n    if (isInitialTransition || isActivationTransition) {\n      this._measureResponderRegion();\n    }\n    if (isPressInSignal(prevState) && signal === 'LONG_PRESS_DETECTED') {\n      const {\n        onLongPress\n      } = this._config;\n      if (onLongPress != null) {\n        onLongPress(event);\n      }\n    }\n    const isPrevActive = isActiveSignal(prevState);\n    const isNextActive = isActiveSignal(nextState);\n    if (!isPrevActive && isNextActive) {\n      this._activate(event);\n    } else if (isPrevActive && !isNextActive) {\n      this._deactivate(event);\n    }\n    if (isPressInSignal(prevState) && signal === 'RESPONDER_RELEASE') {\n      if (!isNextActive && !isPrevActive) {\n        this._activate(event);\n        this._deactivate(event);\n      }\n      const {\n        onLongPress,\n        onPress,\n        android_disableSound\n      } = this._config;\n      if (onPress != null) {\n        const isPressCanceledByLongPress = onLongPress != null && prevState === 'RESPONDER_ACTIVE_LONG_PRESS_IN' && this._shouldLongPressCancelPress();\n        if (!isPressCanceledByLongPress) {\n          if (Platform.OS === 'android' && android_disableSound !== true) {\n            SoundManager.playTouchSound();\n          }\n          onPress(event);\n        }\n      }\n    }\n    this._cancelPressDelayTimeout();\n  }\n  _activate(event) {\n    const {\n      onPressIn\n    } = this._config;\n    const {\n      pageX,\n      pageY\n    } = getTouchFromPressEvent(event);\n    this._touchActivatePosition = {\n      pageX,\n      pageY\n    };\n    this._touchActivateTime = Date.now();\n    if (onPressIn != null) {\n      onPressIn(event);\n    }\n  }\n  _deactivate(event) {\n    const {\n      onPressOut\n    } = this._config;\n    if (onPressOut != null) {\n      const minPressDuration = normalizeDelay(this._config.minPressDuration, 0, DEFAULT_MIN_PRESS_DURATION);\n      const pressDuration = Date.now() - (this._touchActivateTime ?? 0);\n      const delayPressOut = Math.max(minPressDuration - pressDuration, normalizeDelay(this._config.delayPressOut));\n      if (delayPressOut > 0) {\n        event.persist();\n        this._pressOutDelayTimeout = setTimeout(() => {\n          onPressOut(event);\n        }, delayPressOut);\n      } else {\n        onPressOut(event);\n      }\n    }\n    this._touchActivateTime = null;\n  }\n  _measureResponderRegion() {\n    if (this._responderID == null) {\n      return;\n    }\n    if (typeof this._responderID === 'number') {\n      UIManager.measure(this._responderID, this._measureCallback);\n    } else {\n      this._responderID.measure(this._measureCallback);\n    }\n  }\n  _measureCallback = (left, top, width, height, pageX, pageY) => {\n    if (!left && !top && !width && !height && !pageX && !pageY) {\n      return;\n    }\n    this._responderRegion = {\n      bottom: pageY + height,\n      left: pageX,\n      right: pageX + width,\n      top: pageY\n    };\n  };\n  _isTouchWithinResponderRegion(touch, responderRegion) {\n    const hitSlop = normalizeRect(this._config.hitSlop);\n    const pressRectOffset = normalizeRect(this._config.pressRectOffset);\n    let regionBottom = responderRegion.bottom;\n    let regionLeft = responderRegion.left;\n    let regionRight = responderRegion.right;\n    let regionTop = responderRegion.top;\n    if (hitSlop != null) {\n      if (hitSlop.bottom != null) {\n        regionBottom += hitSlop.bottom;\n      }\n      if (hitSlop.left != null) {\n        regionLeft -= hitSlop.left;\n      }\n      if (hitSlop.right != null) {\n        regionRight += hitSlop.right;\n      }\n      if (hitSlop.top != null) {\n        regionTop -= hitSlop.top;\n      }\n    }\n    regionBottom += pressRectOffset?.bottom ?? DEFAULT_PRESS_RECT_OFFSETS.bottom;\n    regionLeft -= pressRectOffset?.left ?? DEFAULT_PRESS_RECT_OFFSETS.left;\n    regionRight += pressRectOffset?.right ?? DEFAULT_PRESS_RECT_OFFSETS.right;\n    regionTop -= pressRectOffset?.top ?? DEFAULT_PRESS_RECT_OFFSETS.top;\n    return touch.pageX > regionLeft && touch.pageX < regionRight && touch.pageY > regionTop && touch.pageY < regionBottom;\n  }\n  _handleLongPress(event) {\n    if (this._touchState === 'RESPONDER_ACTIVE_PRESS_IN' || this._touchState === 'RESPONDER_ACTIVE_LONG_PRESS_IN') {\n      this._receiveSignal('LONG_PRESS_DETECTED', event);\n    }\n  }\n  _shouldLongPressCancelPress() {\n    return this._config.onLongPressShouldCancelPress_DEPRECATED == null || this._config.onLongPressShouldCancelPress_DEPRECATED();\n  }\n  _cancelHoverInDelayTimeout() {\n    if (this._hoverInDelayTimeout != null) {\n      clearTimeout(this._hoverInDelayTimeout);\n      this._hoverInDelayTimeout = null;\n    }\n  }\n  _cancelHoverOutDelayTimeout() {\n    if (this._hoverOutDelayTimeout != null) {\n      clearTimeout(this._hoverOutDelayTimeout);\n      this._hoverOutDelayTimeout = null;\n    }\n  }\n  _cancelLongPressDelayTimeout() {\n    if (this._longPressDelayTimeout != null) {\n      clearTimeout(this._longPressDelayTimeout);\n      this._longPressDelayTimeout = null;\n    }\n  }\n  _cancelPressDelayTimeout() {\n    if (this._pressDelayTimeout != null) {\n      clearTimeout(this._pressDelayTimeout);\n      this._pressDelayTimeout = null;\n    }\n  }\n  _cancelPressOutDelayTimeout() {\n    if (this._pressOutDelayTimeout != null) {\n      clearTimeout(this._pressOutDelayTimeout);\n      this._pressOutDelayTimeout = null;\n    }\n  }\n}\nfunction normalizeDelay(delay, min = 0, fallback = 0) {\n  return Math.max(min, delay ?? fallback);\n}\nconst getTouchFromPressEvent = event => {\n  const {\n    changedTouches,\n    touches\n  } = event.nativeEvent;\n  if (touches != null && touches.length > 0) {\n    return touches[0];\n  }\n  if (changedTouches != null && changedTouches.length > 0) {\n    return changedTouches[0];\n  }\n  return event.nativeEvent;\n};\nfunction convertPointerEventToMouseEvent(input) {\n  const {\n    clientX,\n    clientY\n  } = input.nativeEvent;\n  return Object.assign({}, input, {\n    nativeEvent: {\n      clientX,\n      clientY,\n      pageX: clientX,\n      pageY: clientY,\n      timestamp: input.timeStamp\n    }\n  });\n}","map":{"version":3,"names":["SoundManager","ReactNativeFeatureFlags","UIManager","normalizeRect","Platform","isHoverEnabled","PressabilityPerformanceEventEmitter","invariant","React","Transitions","Object","freeze","NOT_RESPONDER","DELAY","RESPONDER_GRANT","RESPONDER_RELEASE","RESPONDER_TERMINATED","ENTER_PRESS_RECT","LEAVE_PRESS_RECT","LONG_PRESS_DETECTED","RESPONDER_INACTIVE_PRESS_IN","RESPONDER_INACTIVE_PRESS_OUT","RESPONDER_ACTIVE_PRESS_IN","RESPONDER_ACTIVE_PRESS_OUT","RESPONDER_ACTIVE_LONG_PRESS_IN","RESPONDER_ACTIVE_LONG_PRESS_OUT","ERROR","isActiveSignal","signal","isActivationSignal","isPressInSignal","isTerminalSignal","DEFAULT_LONG_PRESS_DELAY_MS","DEFAULT_PRESS_RECT_OFFSETS","bottom","left","right","top","DEFAULT_MIN_PRESS_DURATION","DEFAULT_LONG_PRESS_DEACTIVATION_DISTANCE","longPressDeactivationDistance","Pressability","_eventHandlers","_hoverInDelayTimeout","_hoverOutDelayTimeout","_isHovered","_longPressDelayTimeout","_pressDelayTimeout","_pressOutDelayTimeout","_responderID","_responderRegion","_touchState","constructor","config","configure","_config","reset","_cancelHoverInDelayTimeout","_cancelHoverOutDelayTimeout","_cancelLongPressDelayTimeout","_cancelPressDelayTimeout","_cancelPressOutDelayTimeout","getEventHandlers","_createEventHandlers","setLongPressDeactivationDistance","distance","focusEventHandlers","onBlur","event","onFocus","responderEventHandlers","onStartShouldSetResponder","disabled","onStartShouldSetResponder_DEPRECATED","onResponderGrant","persist","currentTarget","_receiveSignal","delayPressIn","normalizeDelay","setTimeout","delayLongPress","_handleLongPress","onResponderMove","onPressMove","responderRegion","touch","getTouchFromPressEvent","_touchActivatePosition","deltaX","pageX","deltaY","pageY","Math","hypot","_isTouchWithinResponderRegion","onResponderRelease","onResponderTerminate","onResponderTerminationRequest","cancelable","onResponderTerminationRequest_DEPRECATED","onClick","onPress","process","env","NODE_ENV","testOnly_pressabilityConfig","shouldPressibilityUseW3CPointerEventsForHover","hoverPointerEvents","onPointerEnter","undefined","onPointerLeave","onHoverIn","onHoverOut","delayHoverIn","convertPointerEventToMouseEvent","delayHoverOut","assign","mouseEventHandlers","OS","onMouseEnter","onMouseLeave","nativeEvent","timestamp","emitEvent","nativeTimestamp","prevState","nextState","_performTransitionSideEffects","isInitialTransition","isActivationTransition","_measureResponderRegion","onLongPress","isPrevActive","isNextActive","_activate","_deactivate","android_disableSound","isPressCanceledByLongPress","_shouldLongPressCancelPress","playTouchSound","onPressIn","_touchActivateTime","Date","now","onPressOut","minPressDuration","pressDuration","delayPressOut","max","measure","_measureCallback","width","height","hitSlop","pressRectOffset","regionBottom","regionLeft","regionRight","regionTop","onLongPressShouldCancelPress_DEPRECATED","clearTimeout","delay","min","fallback","changedTouches","touches","length","input","clientX","clientY","timeStamp"],"sources":["C:/Users/Dhrumil/VS Code/projectdemo/src/node_modules/react-native/Libraries/Pressability/Pressability.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow strict-local\n * @format\n */\n\nimport type {HostComponent} from '../Renderer/shims/ReactNativeTypes';\nimport type {\n  BlurEvent,\n  FocusEvent,\n  MouseEvent,\n  PressEvent,\n} from '../Types/CoreEventTypes';\n\nimport SoundManager from '../Components/Sound/SoundManager';\nimport ReactNativeFeatureFlags from '../ReactNative/ReactNativeFeatureFlags';\nimport UIManager from '../ReactNative/UIManager';\nimport {type RectOrSize, normalizeRect} from '../StyleSheet/Rect';\nimport {type PointerEvent} from '../Types/CoreEventTypes';\nimport Platform from '../Utilities/Platform';\nimport {isHoverEnabled} from './HoverState';\nimport PressabilityPerformanceEventEmitter from './PressabilityPerformanceEventEmitter.js';\nimport {type PressabilityTouchSignal as TouchSignal} from './PressabilityTypes.js';\nimport invariant from 'invariant';\nimport * as React from 'react';\n\nexport type PressabilityConfig = $ReadOnly<{|\n  /**\n   * Whether a press gesture can be interrupted by a parent gesture such as a\n   * scroll event. Defaults to true.\n   */\n  cancelable?: ?boolean,\n\n  /**\n   * Whether to disable initialization of the press gesture.\n   */\n  disabled?: ?boolean,\n\n  /**\n   * Amount to extend the `VisualRect` by to create `HitRect`.\n   */\n  hitSlop?: ?RectOrSize,\n\n  /**\n   * Amount to extend the `HitRect` by to create `PressRect`.\n   */\n  pressRectOffset?: ?RectOrSize,\n\n  /**\n   * Whether to disable the systemm sound when `onPress` fires on Android.\n   **/\n  android_disableSound?: ?boolean,\n\n  /**\n   * Duration to wait after hover in before calling `onHoverIn`.\n   */\n  delayHoverIn?: ?number,\n\n  /**\n   * Duration to wait after hover out before calling `onHoverOut`.\n   */\n  delayHoverOut?: ?number,\n\n  /**\n   * Duration (in addition to `delayPressIn`) after which a press gesture is\n   * considered a long press gesture. Defaults to 500 (milliseconds).\n   */\n  delayLongPress?: ?number,\n\n  /**\n   * Duration to wait after press down before calling `onPressIn`.\n   */\n  delayPressIn?: ?number,\n\n  /**\n   * Duration to wait after letting up before calling `onPressOut`.\n   */\n  delayPressOut?: ?number,\n\n  /**\n   * Minimum duration to wait between calling `onPressIn` and `onPressOut`.\n   */\n  minPressDuration?: ?number,\n\n  /**\n   * Called after the element loses focus.\n   */\n  onBlur?: ?(event: BlurEvent) => mixed,\n\n  /**\n   * Called after the element is focused.\n   */\n  onFocus?: ?(event: FocusEvent) => mixed,\n\n  /**\n   * Called when the hover is activated to provide visual feedback.\n   */\n  onHoverIn?: ?(event: MouseEvent) => mixed,\n\n  /**\n   * Called when the hover is deactivated to undo visual feedback.\n   */\n  onHoverOut?: ?(event: MouseEvent) => mixed,\n\n  /**\n   * Called when a long press gesture has been triggered.\n   */\n  onLongPress?: ?(event: PressEvent) => mixed,\n\n  /**\n   * Called when a press gesture has been triggered.\n   */\n  onPress?: ?(event: PressEvent) => mixed,\n\n  /**\n   * Called when the press is activated to provide visual feedback.\n   */\n  onPressIn?: ?(event: PressEvent) => mixed,\n\n  /**\n   * Called when the press location moves. (This should rarely be used.)\n   */\n  onPressMove?: ?(event: PressEvent) => mixed,\n\n  /**\n   * Called when the press is deactivated to undo visual feedback.\n   */\n  onPressOut?: ?(event: PressEvent) => mixed,\n\n  /**\n   * Returns whether a long press gesture should cancel the press gesture.\n   * Defaults to true.\n   */\n  onLongPressShouldCancelPress_DEPRECATED?: ?() => boolean,\n\n  /**\n   * If `cancelable` is set, this will be ignored.\n   *\n   * Returns whether to yield to a lock termination request (e.g. if a native\n   * scroll gesture attempts to steal the responder lock).\n   */\n  onResponderTerminationRequest_DEPRECATED?: ?() => boolean,\n\n  /**\n   * If `disabled` is set, this will be ignored.\n   *\n   * Returns whether to start a press gesture.\n   *\n   * @deprecated\n   */\n  onStartShouldSetResponder_DEPRECATED?: ?() => boolean,\n|}>;\n\nexport type EventHandlers = $ReadOnly<{|\n  onBlur: (event: BlurEvent) => void,\n  onClick: (event: PressEvent) => void,\n  onFocus: (event: FocusEvent) => void,\n  onMouseEnter?: (event: MouseEvent) => void,\n  onMouseLeave?: (event: MouseEvent) => void,\n  onPointerEnter?: (event: PointerEvent) => void,\n  onPointerLeave?: (event: PointerEvent) => void,\n  onResponderGrant: (event: PressEvent) => void,\n  onResponderMove: (event: PressEvent) => void,\n  onResponderRelease: (event: PressEvent) => void,\n  onResponderTerminate: (event: PressEvent) => void,\n  onResponderTerminationRequest: () => boolean,\n  onStartShouldSetResponder: () => boolean,\n|}>;\n\ntype TouchState =\n  | 'NOT_RESPONDER'\n  | 'RESPONDER_INACTIVE_PRESS_IN'\n  | 'RESPONDER_INACTIVE_PRESS_OUT'\n  | 'RESPONDER_ACTIVE_PRESS_IN'\n  | 'RESPONDER_ACTIVE_PRESS_OUT'\n  | 'RESPONDER_ACTIVE_LONG_PRESS_IN'\n  | 'RESPONDER_ACTIVE_LONG_PRESS_OUT'\n  | 'ERROR';\n\nconst Transitions = Object.freeze({\n  NOT_RESPONDER: {\n    DELAY: 'ERROR',\n    RESPONDER_GRANT: 'RESPONDER_INACTIVE_PRESS_IN',\n    RESPONDER_RELEASE: 'ERROR',\n    RESPONDER_TERMINATED: 'ERROR',\n    ENTER_PRESS_RECT: 'ERROR',\n    LEAVE_PRESS_RECT: 'ERROR',\n    LONG_PRESS_DETECTED: 'ERROR',\n  },\n  RESPONDER_INACTIVE_PRESS_IN: {\n    DELAY: 'RESPONDER_ACTIVE_PRESS_IN',\n    RESPONDER_GRANT: 'ERROR',\n    RESPONDER_RELEASE: 'NOT_RESPONDER',\n    RESPONDER_TERMINATED: 'NOT_RESPONDER',\n    ENTER_PRESS_RECT: 'RESPONDER_INACTIVE_PRESS_IN',\n    LEAVE_PRESS_RECT: 'RESPONDER_INACTIVE_PRESS_OUT',\n    LONG_PRESS_DETECTED: 'ERROR',\n  },\n  RESPONDER_INACTIVE_PRESS_OUT: {\n    DELAY: 'RESPONDER_ACTIVE_PRESS_OUT',\n    RESPONDER_GRANT: 'ERROR',\n    RESPONDER_RELEASE: 'NOT_RESPONDER',\n    RESPONDER_TERMINATED: 'NOT_RESPONDER',\n    ENTER_PRESS_RECT: 'RESPONDER_INACTIVE_PRESS_IN',\n    LEAVE_PRESS_RECT: 'RESPONDER_INACTIVE_PRESS_OUT',\n    LONG_PRESS_DETECTED: 'ERROR',\n  },\n  RESPONDER_ACTIVE_PRESS_IN: {\n    DELAY: 'ERROR',\n    RESPONDER_GRANT: 'ERROR',\n    RESPONDER_RELEASE: 'NOT_RESPONDER',\n    RESPONDER_TERMINATED: 'NOT_RESPONDER',\n    ENTER_PRESS_RECT: 'RESPONDER_ACTIVE_PRESS_IN',\n    LEAVE_PRESS_RECT: 'RESPONDER_ACTIVE_PRESS_OUT',\n    LONG_PRESS_DETECTED: 'RESPONDER_ACTIVE_LONG_PRESS_IN',\n  },\n  RESPONDER_ACTIVE_PRESS_OUT: {\n    DELAY: 'ERROR',\n    RESPONDER_GRANT: 'ERROR',\n    RESPONDER_RELEASE: 'NOT_RESPONDER',\n    RESPONDER_TERMINATED: 'NOT_RESPONDER',\n    ENTER_PRESS_RECT: 'RESPONDER_ACTIVE_PRESS_IN',\n    LEAVE_PRESS_RECT: 'RESPONDER_ACTIVE_PRESS_OUT',\n    LONG_PRESS_DETECTED: 'ERROR',\n  },\n  RESPONDER_ACTIVE_LONG_PRESS_IN: {\n    DELAY: 'ERROR',\n    RESPONDER_GRANT: 'ERROR',\n    RESPONDER_RELEASE: 'NOT_RESPONDER',\n    RESPONDER_TERMINATED: 'NOT_RESPONDER',\n    ENTER_PRESS_RECT: 'RESPONDER_ACTIVE_LONG_PRESS_IN',\n    LEAVE_PRESS_RECT: 'RESPONDER_ACTIVE_LONG_PRESS_OUT',\n    LONG_PRESS_DETECTED: 'RESPONDER_ACTIVE_LONG_PRESS_IN',\n  },\n  RESPONDER_ACTIVE_LONG_PRESS_OUT: {\n    DELAY: 'ERROR',\n    RESPONDER_GRANT: 'ERROR',\n    RESPONDER_RELEASE: 'NOT_RESPONDER',\n    RESPONDER_TERMINATED: 'NOT_RESPONDER',\n    ENTER_PRESS_RECT: 'RESPONDER_ACTIVE_LONG_PRESS_IN',\n    LEAVE_PRESS_RECT: 'RESPONDER_ACTIVE_LONG_PRESS_OUT',\n    LONG_PRESS_DETECTED: 'ERROR',\n  },\n  ERROR: {\n    DELAY: 'NOT_RESPONDER',\n    RESPONDER_GRANT: 'RESPONDER_INACTIVE_PRESS_IN',\n    RESPONDER_RELEASE: 'NOT_RESPONDER',\n    RESPONDER_TERMINATED: 'NOT_RESPONDER',\n    ENTER_PRESS_RECT: 'NOT_RESPONDER',\n    LEAVE_PRESS_RECT: 'NOT_RESPONDER',\n    LONG_PRESS_DETECTED: 'NOT_RESPONDER',\n  },\n});\n\nconst isActiveSignal = (signal: TouchState) =>\n  signal === 'RESPONDER_ACTIVE_PRESS_IN' ||\n  signal === 'RESPONDER_ACTIVE_LONG_PRESS_IN';\n\nconst isActivationSignal = (signal: TouchState) =>\n  signal === 'RESPONDER_ACTIVE_PRESS_OUT' ||\n  signal === 'RESPONDER_ACTIVE_PRESS_IN';\n\nconst isPressInSignal = (signal: TouchState) =>\n  signal === 'RESPONDER_INACTIVE_PRESS_IN' ||\n  signal === 'RESPONDER_ACTIVE_PRESS_IN' ||\n  signal === 'RESPONDER_ACTIVE_LONG_PRESS_IN';\n\nconst isTerminalSignal = (signal: TouchSignal) =>\n  signal === 'RESPONDER_TERMINATED' || signal === 'RESPONDER_RELEASE';\n\nconst DEFAULT_LONG_PRESS_DELAY_MS = 500;\nconst DEFAULT_PRESS_RECT_OFFSETS = {\n  bottom: 30,\n  left: 20,\n  right: 20,\n  top: 20,\n};\nconst DEFAULT_MIN_PRESS_DURATION = 130;\n\nconst DEFAULT_LONG_PRESS_DEACTIVATION_DISTANCE = 10;\nlet longPressDeactivationDistance = DEFAULT_LONG_PRESS_DEACTIVATION_DISTANCE;\n/**\n * Pressability implements press handling capabilities.\n *\n * =========================== Pressability Tutorial ===========================\n *\n * The `Pressability` class helps you create press interactions by analyzing the\n * geometry of elements and observing when another responder (e.g. ScrollView)\n * has stolen the touch lock. It offers hooks for your component to provide\n * interaction feedback to the user:\n *\n * - When a press has activated (e.g. highlight an element)\n * - When a press has deactivated (e.g. un-highlight an element)\n * - When a press sould trigger an action, meaning it activated and deactivated\n *   while within the geometry of the element without the lock being stolen.\n *\n * A high quality interaction isn't as simple as you might think. There should\n * be a slight delay before activation. Moving your finger beyond an element's\n * bounds should trigger deactivation, but moving the same finger back within an\n * element's bounds should trigger reactivation.\n *\n * In order to use `Pressability`, do the following:\n *\n * 1. Instantiate `Pressability` and store it on your component's state.\n *\n *    state = {\n *      pressability: new Pressability({\n *        // ...\n *      }),\n *    };\n *\n * 2. Choose the rendered component who should collect the press events. On that\n *    element, spread `pressability.getEventHandlers()` into its props.\n *\n *    return (\n *      <View {...this.state.pressability.getEventHandlers()} />\n *    );\n *\n * 3. Reset `Pressability` when your component unmounts.\n *\n *    componentWillUnmount() {\n *      this.state.pressability.reset();\n *    }\n *\n * ==================== Pressability Implementation Details ====================\n *\n * `Pressability` only assumes that there exists a `HitRect` node. The `PressRect`\n * is an abstract box that is extended beyond the `HitRect`.\n *\n * # Geometry\n *\n *  ┌────────────────────────┐\n *  │  ┌──────────────────┐  │ - Presses start anywhere within `HitRect`, which\n *  │  │  ┌────────────┐  │  │   is expanded via the prop `hitSlop`.\n *  │  │  │ VisualRect │  │  │\n *  │  │  └────────────┘  │  │ - When pressed down for sufficient amount of time\n *  │  │    HitRect       │  │   before letting up, `VisualRect` activates for\n *  │  └──────────────────┘  │   as long as the press stays within `PressRect`.\n *  │       PressRect    o   │\n *  └────────────────────│───┘\n *          Out Region   └────── `PressRect`, which is expanded via the prop\n *                               `pressRectOffset`, allows presses to move\n *                               beyond `HitRect` while maintaining activation\n *                               and being eligible for a \"press\".\n *\n * # State Machine\n *\n * ┌───────────────┐ ◀──── RESPONDER_RELEASE\n * │ NOT_RESPONDER │\n * └───┬───────────┘ ◀──── RESPONDER_TERMINATED\n *     │\n *     │ RESPONDER_GRANT (HitRect)\n *     │\n *     ▼\n * ┌─────────────────────┐          ┌───────────────────┐              ┌───────────────────┐\n * │ RESPONDER_INACTIVE_ │  DELAY   │ RESPONDER_ACTIVE_ │  T + DELAY   │ RESPONDER_ACTIVE_ │\n * │ PRESS_IN            ├────────▶ │ PRESS_IN          ├────────────▶ │ LONG_PRESS_IN     │\n * └─┬───────────────────┘          └─┬─────────────────┘              └─┬─────────────────┘\n *   │           ▲                    │           ▲                      │           ▲\n *   │LEAVE_     │                    │LEAVE_     │                      │LEAVE_     │\n *   │PRESS_RECT │ENTER_              │PRESS_RECT │ENTER_                │PRESS_RECT │ENTER_\n *   │           │PRESS_RECT          │           │PRESS_RECT            │           │PRESS_RECT\n *   ▼           │                    ▼           │                      ▼           │\n * ┌─────────────┴───────┐          ┌─────────────┴─────┐              ┌─────────────┴─────┐\n * │ RESPONDER_INACTIVE_ │  DELAY   │ RESPONDER_ACTIVE_ │              │ RESPONDER_ACTIVE_ │\n * │ PRESS_OUT           ├────────▶ │ PRESS_OUT         │              │ LONG_PRESS_OUT    │\n * └─────────────────────┘          └───────────────────┘              └───────────────────┘\n *\n * T + DELAY => LONG_PRESS_DELAY + DELAY\n *\n * Not drawn are the side effects of each transition. The most important side\n * effect is the invocation of `onPress` and `onLongPress` that occur when a\n * responder is release while in the \"press in\" states.\n */\nexport default class Pressability {\n  _config: PressabilityConfig;\n  _eventHandlers: ?EventHandlers = null;\n  _hoverInDelayTimeout: ?TimeoutID = null;\n  _hoverOutDelayTimeout: ?TimeoutID = null;\n  _isHovered: boolean = false;\n  _longPressDelayTimeout: ?TimeoutID = null;\n  _pressDelayTimeout: ?TimeoutID = null;\n  _pressOutDelayTimeout: ?TimeoutID = null;\n  _responderID: ?number | React.ElementRef<HostComponent<mixed>> = null;\n  _responderRegion: ?$ReadOnly<{|\n    bottom: number,\n    left: number,\n    right: number,\n    top: number,\n  |}> = null;\n  _touchActivatePosition: ?$ReadOnly<{|\n    pageX: number,\n    pageY: number,\n  |}>;\n  _touchActivateTime: ?number;\n  _touchState: TouchState = 'NOT_RESPONDER';\n\n  constructor(config: PressabilityConfig) {\n    this.configure(config);\n  }\n\n  configure(config: PressabilityConfig): void {\n    this._config = config;\n  }\n\n  /**\n   * Resets any pending timers. This should be called on unmount.\n   */\n  reset(): void {\n    this._cancelHoverInDelayTimeout();\n    this._cancelHoverOutDelayTimeout();\n    this._cancelLongPressDelayTimeout();\n    this._cancelPressDelayTimeout();\n    this._cancelPressOutDelayTimeout();\n\n    // Ensure that, if any async event handlers are fired after unmount\n    // due to a race, we don't call any configured callbacks.\n    this._config = Object.freeze({});\n  }\n\n  /**\n   * Returns a set of props to spread into the interactive element.\n   */\n  getEventHandlers(): EventHandlers {\n    if (this._eventHandlers == null) {\n      this._eventHandlers = this._createEventHandlers();\n    }\n    return this._eventHandlers;\n  }\n\n  static setLongPressDeactivationDistance(distance: number): void {\n    longPressDeactivationDistance = distance;\n  }\n\n  _createEventHandlers(): EventHandlers {\n    const focusEventHandlers = {\n      onBlur: (event: BlurEvent): void => {\n        const {onBlur} = this._config;\n        if (onBlur != null) {\n          onBlur(event);\n        }\n      },\n      onFocus: (event: FocusEvent): void => {\n        const {onFocus} = this._config;\n        if (onFocus != null) {\n          onFocus(event);\n        }\n      },\n    };\n\n    const responderEventHandlers = {\n      onStartShouldSetResponder: (): boolean => {\n        const {disabled} = this._config;\n        if (disabled == null) {\n          const {onStartShouldSetResponder_DEPRECATED} = this._config;\n          return onStartShouldSetResponder_DEPRECATED == null\n            ? true\n            : onStartShouldSetResponder_DEPRECATED();\n        }\n        return !disabled;\n      },\n\n      onResponderGrant: (event: PressEvent): void => {\n        event.persist();\n\n        this._cancelPressOutDelayTimeout();\n\n        this._responderID = event.currentTarget;\n        this._touchState = 'NOT_RESPONDER';\n        this._receiveSignal('RESPONDER_GRANT', event);\n\n        const delayPressIn = normalizeDelay(this._config.delayPressIn);\n        if (delayPressIn > 0) {\n          this._pressDelayTimeout = setTimeout(() => {\n            this._receiveSignal('DELAY', event);\n          }, delayPressIn);\n        } else {\n          this._receiveSignal('DELAY', event);\n        }\n\n        const delayLongPress = normalizeDelay(\n          this._config.delayLongPress,\n          10,\n          DEFAULT_LONG_PRESS_DELAY_MS - delayPressIn,\n        );\n        this._longPressDelayTimeout = setTimeout(() => {\n          this._handleLongPress(event);\n        }, delayLongPress + delayPressIn);\n      },\n\n      onResponderMove: (event: PressEvent): void => {\n        const {onPressMove} = this._config;\n        if (onPressMove != null) {\n          onPressMove(event);\n        }\n\n        // Region may not have finished being measured, yet.\n        const responderRegion = this._responderRegion;\n        if (responderRegion == null) {\n          return;\n        }\n\n        const touch = getTouchFromPressEvent(event);\n        if (touch == null) {\n          this._cancelLongPressDelayTimeout();\n          this._receiveSignal('LEAVE_PRESS_RECT', event);\n          return;\n        }\n\n        if (this._touchActivatePosition != null) {\n          const deltaX = this._touchActivatePosition.pageX - touch.pageX;\n          const deltaY = this._touchActivatePosition.pageY - touch.pageY;\n          if (Math.hypot(deltaX, deltaY) > longPressDeactivationDistance) {\n            this._cancelLongPressDelayTimeout();\n          }\n        }\n\n        if (this._isTouchWithinResponderRegion(touch, responderRegion)) {\n          this._receiveSignal('ENTER_PRESS_RECT', event);\n        } else {\n          this._cancelLongPressDelayTimeout();\n          this._receiveSignal('LEAVE_PRESS_RECT', event);\n        }\n      },\n\n      onResponderRelease: (event: PressEvent): void => {\n        this._receiveSignal('RESPONDER_RELEASE', event);\n      },\n\n      onResponderTerminate: (event: PressEvent): void => {\n        this._receiveSignal('RESPONDER_TERMINATED', event);\n      },\n\n      onResponderTerminationRequest: (): boolean => {\n        const {cancelable} = this._config;\n        if (cancelable == null) {\n          const {onResponderTerminationRequest_DEPRECATED} = this._config;\n          return onResponderTerminationRequest_DEPRECATED == null\n            ? true\n            : onResponderTerminationRequest_DEPRECATED();\n        }\n        return cancelable;\n      },\n\n      onClick: (event: PressEvent): void => {\n        const {onPress, disabled} = this._config;\n        if (onPress != null && disabled !== true) {\n          onPress(event);\n        }\n      },\n    };\n\n    if (process.env.NODE_ENV === 'test') {\n      // We are setting this in order to find this node in ReactNativeTestTools\n      // $FlowFixMe[prop-missing]\n      responderEventHandlers.onStartShouldSetResponder.testOnly_pressabilityConfig =\n        () => this._config;\n    }\n\n    if (\n      ReactNativeFeatureFlags.shouldPressibilityUseW3CPointerEventsForHover()\n    ) {\n      const hoverPointerEvents = {\n        onPointerEnter: (undefined: void | (PointerEvent => void)),\n        onPointerLeave: (undefined: void | (PointerEvent => void)),\n      };\n      const {onHoverIn, onHoverOut} = this._config;\n      if (onHoverIn != null) {\n        hoverPointerEvents.onPointerEnter = (event: PointerEvent) => {\n          this._isHovered = true;\n          this._cancelHoverOutDelayTimeout();\n          if (onHoverIn != null) {\n            const delayHoverIn = normalizeDelay(this._config.delayHoverIn);\n            if (delayHoverIn > 0) {\n              event.persist();\n              this._hoverInDelayTimeout = setTimeout(() => {\n                onHoverIn(convertPointerEventToMouseEvent(event));\n              }, delayHoverIn);\n            } else {\n              onHoverIn(convertPointerEventToMouseEvent(event));\n            }\n          }\n        };\n      }\n      if (onHoverOut != null) {\n        hoverPointerEvents.onPointerLeave = (event: PointerEvent) => {\n          if (this._isHovered) {\n            this._isHovered = false;\n            this._cancelHoverInDelayTimeout();\n            if (onHoverOut != null) {\n              const delayHoverOut = normalizeDelay(this._config.delayHoverOut);\n              if (delayHoverOut > 0) {\n                event.persist();\n                this._hoverOutDelayTimeout = setTimeout(() => {\n                  onHoverOut(convertPointerEventToMouseEvent(event));\n                }, delayHoverOut);\n              } else {\n                onHoverOut(convertPointerEventToMouseEvent(event));\n              }\n            }\n          }\n        };\n      }\n      return {\n        ...focusEventHandlers,\n        ...responderEventHandlers,\n        ...hoverPointerEvents,\n      };\n    } else {\n      const mouseEventHandlers =\n        Platform.OS === 'ios' || Platform.OS === 'android'\n          ? null\n          : {\n              onMouseEnter: (event: MouseEvent): void => {\n                if (isHoverEnabled()) {\n                  this._isHovered = true;\n                  this._cancelHoverOutDelayTimeout();\n                  const {onHoverIn} = this._config;\n                  if (onHoverIn != null) {\n                    const delayHoverIn = normalizeDelay(\n                      this._config.delayHoverIn,\n                    );\n                    if (delayHoverIn > 0) {\n                      event.persist();\n                      this._hoverInDelayTimeout = setTimeout(() => {\n                        onHoverIn(event);\n                      }, delayHoverIn);\n                    } else {\n                      onHoverIn(event);\n                    }\n                  }\n                }\n              },\n\n              onMouseLeave: (event: MouseEvent): void => {\n                if (this._isHovered) {\n                  this._isHovered = false;\n                  this._cancelHoverInDelayTimeout();\n                  const {onHoverOut} = this._config;\n                  if (onHoverOut != null) {\n                    const delayHoverOut = normalizeDelay(\n                      this._config.delayHoverOut,\n                    );\n                    if (delayHoverOut > 0) {\n                      event.persist();\n                      this._hoverInDelayTimeout = setTimeout(() => {\n                        onHoverOut(event);\n                      }, delayHoverOut);\n                    } else {\n                      onHoverOut(event);\n                    }\n                  }\n                }\n              },\n            };\n      return {\n        ...focusEventHandlers,\n        ...responderEventHandlers,\n        ...mouseEventHandlers,\n      };\n    }\n  }\n\n  /**\n   * Receives a state machine signal, performs side effects of the transition\n   * and stores the new state. Validates the transition as well.\n   */\n  _receiveSignal(signal: TouchSignal, event: PressEvent): void {\n    // Especially on iOS, not all events have timestamps associated.\n    // For telemetry purposes, this doesn't matter too much, as long as *some* do.\n    // Since the native timestamp is integral for logging telemetry, just skip\n    // events if they don't have a timestamp attached.\n    if (event.nativeEvent.timestamp != null) {\n      PressabilityPerformanceEventEmitter.emitEvent(() => {\n        return {\n          signal,\n          nativeTimestamp: event.nativeEvent.timestamp,\n        };\n      });\n    }\n\n    const prevState = this._touchState;\n    const nextState = Transitions[prevState]?.[signal];\n    if (this._responderID == null && signal === 'RESPONDER_RELEASE') {\n      return;\n    }\n    invariant(\n      nextState != null && nextState !== 'ERROR',\n      'Pressability: Invalid signal `%s` for state `%s` on responder: %s',\n      signal,\n      prevState,\n      typeof this._responderID === 'number'\n        ? this._responderID\n        : '<<host component>>',\n    );\n    if (prevState !== nextState) {\n      this._performTransitionSideEffects(prevState, nextState, signal, event);\n      this._touchState = nextState;\n    }\n  }\n\n  /**\n   * Performs a transition between touchable states and identify any activations\n   * or deactivations (and callback invocations).\n   */\n  _performTransitionSideEffects(\n    prevState: TouchState,\n    nextState: TouchState,\n    signal: TouchSignal,\n    event: PressEvent,\n  ): void {\n    if (isTerminalSignal(signal)) {\n      this._touchActivatePosition = null;\n      this._cancelLongPressDelayTimeout();\n    }\n\n    const isInitialTransition =\n      prevState === 'NOT_RESPONDER' &&\n      nextState === 'RESPONDER_INACTIVE_PRESS_IN';\n\n    const isActivationTransition =\n      !isActivationSignal(prevState) && isActivationSignal(nextState);\n\n    if (isInitialTransition || isActivationTransition) {\n      this._measureResponderRegion();\n    }\n\n    if (isPressInSignal(prevState) && signal === 'LONG_PRESS_DETECTED') {\n      const {onLongPress} = this._config;\n      if (onLongPress != null) {\n        onLongPress(event);\n      }\n    }\n\n    const isPrevActive = isActiveSignal(prevState);\n    const isNextActive = isActiveSignal(nextState);\n\n    if (!isPrevActive && isNextActive) {\n      this._activate(event);\n    } else if (isPrevActive && !isNextActive) {\n      this._deactivate(event);\n    }\n\n    if (isPressInSignal(prevState) && signal === 'RESPONDER_RELEASE') {\n      // If we never activated (due to delays), activate and deactivate now.\n      if (!isNextActive && !isPrevActive) {\n        this._activate(event);\n        this._deactivate(event);\n      }\n      const {onLongPress, onPress, android_disableSound} = this._config;\n      if (onPress != null) {\n        const isPressCanceledByLongPress =\n          onLongPress != null &&\n          prevState === 'RESPONDER_ACTIVE_LONG_PRESS_IN' &&\n          this._shouldLongPressCancelPress();\n        if (!isPressCanceledByLongPress) {\n          if (Platform.OS === 'android' && android_disableSound !== true) {\n            SoundManager.playTouchSound();\n          }\n          onPress(event);\n        }\n      }\n    }\n\n    this._cancelPressDelayTimeout();\n  }\n\n  _activate(event: PressEvent): void {\n    const {onPressIn} = this._config;\n    const {pageX, pageY} = getTouchFromPressEvent(event);\n    this._touchActivatePosition = {pageX, pageY};\n    this._touchActivateTime = Date.now();\n    if (onPressIn != null) {\n      onPressIn(event);\n    }\n  }\n\n  _deactivate(event: PressEvent): void {\n    const {onPressOut} = this._config;\n    if (onPressOut != null) {\n      const minPressDuration = normalizeDelay(\n        this._config.minPressDuration,\n        0,\n        DEFAULT_MIN_PRESS_DURATION,\n      );\n      const pressDuration = Date.now() - (this._touchActivateTime ?? 0);\n      const delayPressOut = Math.max(\n        minPressDuration - pressDuration,\n        normalizeDelay(this._config.delayPressOut),\n      );\n      if (delayPressOut > 0) {\n        event.persist();\n        this._pressOutDelayTimeout = setTimeout(() => {\n          onPressOut(event);\n        }, delayPressOut);\n      } else {\n        onPressOut(event);\n      }\n    }\n    this._touchActivateTime = null;\n  }\n\n  _measureResponderRegion(): void {\n    if (this._responderID == null) {\n      return;\n    }\n\n    if (typeof this._responderID === 'number') {\n      UIManager.measure(this._responderID, this._measureCallback);\n    } else {\n      this._responderID.measure(this._measureCallback);\n    }\n  }\n\n  _measureCallback = (\n    left: number,\n    top: number,\n    width: number,\n    height: number,\n    pageX: number,\n    pageY: number,\n  ) => {\n    if (!left && !top && !width && !height && !pageX && !pageY) {\n      return;\n    }\n    this._responderRegion = {\n      bottom: pageY + height,\n      left: pageX,\n      right: pageX + width,\n      top: pageY,\n    };\n  };\n\n  _isTouchWithinResponderRegion(\n    touch: $PropertyType<PressEvent, 'nativeEvent'>,\n    responderRegion: $ReadOnly<{|\n      bottom: number,\n      left: number,\n      right: number,\n      top: number,\n    |}>,\n  ): boolean {\n    const hitSlop = normalizeRect(this._config.hitSlop);\n    const pressRectOffset = normalizeRect(this._config.pressRectOffset);\n\n    let regionBottom = responderRegion.bottom;\n    let regionLeft = responderRegion.left;\n    let regionRight = responderRegion.right;\n    let regionTop = responderRegion.top;\n\n    if (hitSlop != null) {\n      if (hitSlop.bottom != null) {\n        regionBottom += hitSlop.bottom;\n      }\n      if (hitSlop.left != null) {\n        regionLeft -= hitSlop.left;\n      }\n      if (hitSlop.right != null) {\n        regionRight += hitSlop.right;\n      }\n      if (hitSlop.top != null) {\n        regionTop -= hitSlop.top;\n      }\n    }\n\n    regionBottom +=\n      pressRectOffset?.bottom ?? DEFAULT_PRESS_RECT_OFFSETS.bottom;\n    regionLeft -= pressRectOffset?.left ?? DEFAULT_PRESS_RECT_OFFSETS.left;\n    regionRight += pressRectOffset?.right ?? DEFAULT_PRESS_RECT_OFFSETS.right;\n    regionTop -= pressRectOffset?.top ?? DEFAULT_PRESS_RECT_OFFSETS.top;\n\n    return (\n      touch.pageX > regionLeft &&\n      touch.pageX < regionRight &&\n      touch.pageY > regionTop &&\n      touch.pageY < regionBottom\n    );\n  }\n\n  _handleLongPress(event: PressEvent): void {\n    if (\n      this._touchState === 'RESPONDER_ACTIVE_PRESS_IN' ||\n      this._touchState === 'RESPONDER_ACTIVE_LONG_PRESS_IN'\n    ) {\n      this._receiveSignal('LONG_PRESS_DETECTED', event);\n    }\n  }\n\n  _shouldLongPressCancelPress(): boolean {\n    return (\n      this._config.onLongPressShouldCancelPress_DEPRECATED == null ||\n      this._config.onLongPressShouldCancelPress_DEPRECATED()\n    );\n  }\n\n  _cancelHoverInDelayTimeout(): void {\n    if (this._hoverInDelayTimeout != null) {\n      clearTimeout(this._hoverInDelayTimeout);\n      this._hoverInDelayTimeout = null;\n    }\n  }\n\n  _cancelHoverOutDelayTimeout(): void {\n    if (this._hoverOutDelayTimeout != null) {\n      clearTimeout(this._hoverOutDelayTimeout);\n      this._hoverOutDelayTimeout = null;\n    }\n  }\n\n  _cancelLongPressDelayTimeout(): void {\n    if (this._longPressDelayTimeout != null) {\n      clearTimeout(this._longPressDelayTimeout);\n      this._longPressDelayTimeout = null;\n    }\n  }\n\n  _cancelPressDelayTimeout(): void {\n    if (this._pressDelayTimeout != null) {\n      clearTimeout(this._pressDelayTimeout);\n      this._pressDelayTimeout = null;\n    }\n  }\n\n  _cancelPressOutDelayTimeout(): void {\n    if (this._pressOutDelayTimeout != null) {\n      clearTimeout(this._pressOutDelayTimeout);\n      this._pressOutDelayTimeout = null;\n    }\n  }\n}\n\nfunction normalizeDelay(\n  delay: ?number,\n  min: number = 0,\n  fallback: number = 0,\n): number {\n  return Math.max(min, delay ?? fallback);\n}\n\nconst getTouchFromPressEvent = (event: PressEvent) => {\n  const {changedTouches, touches} = event.nativeEvent;\n\n  if (touches != null && touches.length > 0) {\n    return touches[0];\n  }\n  if (changedTouches != null && changedTouches.length > 0) {\n    return changedTouches[0];\n  }\n  return event.nativeEvent;\n};\n\nfunction convertPointerEventToMouseEvent(input: PointerEvent): MouseEvent {\n  const {clientX, clientY} = input.nativeEvent;\n  return {\n    ...input,\n    nativeEvent: {\n      clientX,\n      clientY,\n      pageX: clientX,\n      pageY: clientY,\n      timestamp: input.timeStamp,\n    },\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{"hasCjsExports":false},"sourceType":"module","externalDependencies":[]}